<HTML>
<HEAD>
<!-- Created by texi2html 1.57 from /home/jaffer/scheme/r3rs.txi on December, 22  2007 -->

<TITLE>Revised(3) Scheme - 6. Standard procedures</TITLE>
</HEAD>
<BODY >
 [<A HREF="r3rs_toc.html">Contents</A>] &#160; [<A HREF="r3rs_7.html">Back</A>] &#160; [<A>Prev</A>] &#160; [<A>Up</A>] &#160; [<A>Next</A>] &#160; [<A HREF="r3rs_9.html">Forward</A>] &#160;<BR><HR><BR>


<H1><A NAME="SEC41">6. Standard procedures</A></H1>

<P>
<A NAME="IDX156"></A>


<P>
<A NAME="IDX157"></A>


<P>
<A NAME="IDX158"></A>


<P>
This chapter describes Scheme's built-in procedures.  The initial (or
"top level") Scheme environment starts out with a number of variables
bound to locations containing useful values, most of which are primitive
procedures that manipulate data.  For example, the variable <CODE>abs</CODE> is
<A NAME="IDX159"></A>
bound to (a location initially containing) a procedure of one argument
that computes the absolute value of a number, and the variable <CODE>+</CODE>
<A NAME="IDX160"></A>
is bound to a procedure that computes sums.




<H2><A NAME="SEC42">6.1 Booleans</A></H2>

<P>
<A NAME="IDX161"></A>


<P>
The standard boolean objects for true and false are written as
<TT>#t</TT> and <TT>#f</TT>.  What really
<A NAME="IDX162"></A>
<A NAME="IDX163"></A>
matters, though, are the objects that the Scheme conditional expressions
(<CODE>if</CODE>, <CODE>cond</CODE>, <CODE>and</CODE>, <CODE>or</CODE>, <CODE>do</CODE>) treat as
<A NAME="IDX164"></A>
<A NAME="IDX165"></A>
<A NAME="IDX166"></A>
<A NAME="IDX167"></A>
<A NAME="IDX168"></A>
true or false.  The phrase "a true value" (or
<A NAME="IDX169"></A>
<A NAME="IDX170"></A>
sometimes just "true") means any object treated as true by the
conditional expressions, and the phrase "a false value" (or "false")
means any object treated as false by the conditional expressions.


<P>
Of all the standard Scheme values, only <TT>#f</TT> and the empty list
<A NAME="IDX171"></A>
count as false in conditional expressions.  Everything else, including
<TT>#t</TT>, pairs, symbols, numbers, strings, vectors, and procedures,
counts as true.


<P>
The empty list counts as false for compatibility with existing programs
and implementations that assume this to be the case.


<P>
Programmers accustomed to other dialects of Lisp should beware that
Scheme distinguishes false and the empty list from the symbol <CODE>nil</CODE>.
<A NAME="IDX172"></A>


<P>
Boolean constants evaluate to themselves, so they don't need to be quoted
in programs.



<PRE>

#t                                     ==&#62;  #t
#f                                     ==&#62;  #f
'#f                                    ==&#62;  #f

</PRE>

<P>
<DL>
<DT><U>essential procedure:</U> <B>not</B> <I>obj</I>
<DD><A NAME="IDX173"></A>


<P>
<CODE>Not</CODE> returns <TT>#t</TT> if <VAR>obj</VAR> is false, and returns
<A NAME="IDX174"></A>
<TT>#f</TT> otherwise.



<PRE>
<TT>(not #t)                               ==&#62;  #f
(not 3)                                ==&#62;  #f
(not (list 3))                         ==&#62;  #f
(not #f)                               ==&#62;  #t
(not '())                              ==&#62;  #t
(not (list))                           ==&#62;  #t
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>boolean?</B> <I>obj</I>
<DD><A NAME="IDX175"></A>


<P>
<CODE>Boolean?</CODE> returns <TT>#t</TT> if <VAR>obj</VAR> is either <TT>#t</TT> or
<A NAME="IDX176"></A>
<TT>#f</TT> and returns <TT>#f</TT> otherwise.



<PRE>
<TT>(boolean? #f)                          ==&#62;  #t
(boolean? 0)                           ==&#62;  #f
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>variable:</U> <B>nil</B>
<DD><A NAME="IDX177"></A>
<DT><U>variable:</U> <B>t</B>
<DD><A NAME="IDX178"></A>


<P>
Some implementations provide variables <CODE>nil</CODE> and <CODE>t</CODE> whose
<A NAME="IDX179"></A>
values in the initial environment are <TT>#f</TT> and <TT>#t</TT>
respectively.



<PRE>
<TT>t                                      ==&#62;  #t
nil                                    ==&#62;  #f
'nil                                   ==&#62;  nil
</TT>
</PRE>

</DL>

<P>
 


<H2><A NAME="SEC43">6.2 Equivalence predicates</A></H2>

<P>
<A NAME="IDX180"></A>


<P>
A <EM>predicate</EM> is a procedure that always returns a boolean
<A NAME="IDX181"></A>
value (<TT>#t</TT> or <TT>#f</TT>).  An <EM>equivalence predicate</EM> is
<A NAME="IDX182"></A>
the computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, <CODE>eq?</CODE> is the finest or most
<A NAME="IDX183"></A>
discriminating, and <CODE>equal?</CODE> is the coarsest.  <CODE>Eqv?</CODE> is
<A NAME="IDX184"></A>
<A NAME="IDX185"></A>
slightly less discriminating than <CODE>eq?</CODE>.  


<P>
Two objects are <EM>operationally equivalent</EM> if and only if
<A NAME="IDX186"></A>
there is no way that they can be distinguished, using Scheme primitives
other than <CODE>eqv?</CODE> or <CODE>eq?</CODE> or those like <CODE>memq</CODE> and
<A NAME="IDX187"></A>
<CODE>assv</CODE> whose meaning is defined explicitly in terms of <CODE>eqv?</CODE> or
<A NAME="IDX188"></A>
<CODE>eq?</CODE>.  It is guaranteed that objects maintain their operational
identity despite being named by variables or fetched from or stored into
data structures.


<P>
This definition can be interpreted in the following ways for various
kinds of objects:



<UL>

<LI>

The two boolean values, <TT>#t</TT> and
<TT>#f</TT>, are operationally distinct because they behave in
opposite ways in conditionals.

<LI>

Two symbols are operationally equivalent if they print
the same way.

<LI>

Two numbers are operationally equivalent if they are numerically
equal (see <CODE>=</CODE>, section see section <A HREF="r3rs_8.html#SEC50">6.5.4 Numerical operations</A>) and are either both exact or both
inexact (see section see section <A HREF="r3rs_8.html#SEC48">6.5.2 Exactness</A>).

<LI>

Two characters are operationally equivalent if they are the same
character according to <CODE>char=?</CODE> (section see section <A HREF="r3rs_8.html#SEC54">6.6 Characters</A>).

<LI>

Two structured mutable objects--pairs, vectors, or strings--are
operationally equivalent if they have operationally equivalent values in
corresponding positions, and applying a mutation procedure to one causes
the other to change as well.  (A mutation procedure is one like
<CODE>set-car!</CODE> which alters a data structure.) For example, two pairs are not operationally equivalent if a
<CODE>set-car!</CODE> operation on one does not change the car field of the
other.

<LI>

There is only one empty list, and it is
operationally equivalent to itself.  All empty vectors are operationally
equivalent to each other.  All empty strings are operationally
equivalent to each other.  Whether there is more than one empty vector
or string is implementation-dependent.

<LI>

Two procedures are operationally equivalent if, when called on
operationally equivalent arguments, they return the same value and
perform the same side effects.

</UL>

<P>
<A NAME="IDX189"></A>
<A NAME="IDX190"></A>
<A NAME="IDX191"></A>
<A NAME="IDX192"></A>
<A NAME="IDX193"></A>


<P>
<DL>
<DT><U>essential procedure:</U> <B>eqv?</B> <I>obj1 obj2</I>
<DD><A NAME="IDX194"></A>


<P>
The <CODE>eqv?</CODE> procedure implements an approximation to the relation of
operational equivalence.
It returns <TT>#t</TT> if it can prove that <VAR>obj1</VAR> and <VAR>obj2</VAR>
are operationally equivalent.  If it can't, it always errs on the
conservative side and returns <TT>#f</TT>.


<P>
The only situation in which it might fail to prove is when <VAR>obj1</VAR>
and <VAR>obj2</VAR> are operationally equivalent procedures that were
created at different times.  In general, operational equivalence of
procedures is uncomputable, but it is guaranteed that <CODE>eqv?</CODE> can
recognize a procedure created at a given time by a given lambda expression as
"being itself."  This is useful for applications in which procedures
are being used to implement objects with local state.



<PRE>
<TT>(eqv? 'a 'a)                           ==&#62;  #t
(eqv? 'a 'b)                           ==&#62;  #f
(eqv? 2 2)                             ==&#62;  #t
(eqv? '() '())                         ==&#62;  #t
(eqv? "" "")                           ==&#62;  #t
(eqv? 100000000 100000000)             ==&#62;  #t
(eqv? (cons 1 2) (cons 1 2))           ==&#62;  #f
(eqv? (lambda () 1)
      (lambda () 2))                   ==&#62;  #f
(eqv? #f 'nil)                         ==&#62;  #f
(let ((p (lambda (x) x)))
  (eqv? p p))                          ==&#62;  #t
</TT>
</PRE>

<P>
The following examples illustrate cases in which <CODE>eqv?</CODE> is
permitted to fail to prove operational equivalence, depending on the
implementation.  (In every case, it will return either <TT>#t</TT> or
<TT>#f</TT>, but which one it returns is implementation-dependent.)
Compare with the last example in the previous set.



<PRE>
<TT>(eqv? (lambda (x) x)
      (lambda (x) x))                  ==&#62;  <EM>unspecified</EM>
(eqv? (lambda (x) x)
      (lambda (y) y))                  ==&#62;  <EM>unspecified</EM>
</TT>
</PRE>

<P>
The next set of examples shows the use of <CODE>eqv?</CODE> with procedures
that have local state.  <CODE>Gen-counter</CODE> must return a distinct
<A NAME="IDX195"></A>
procedure every time, since each procedure has its own internal counter.
<CODE>Gen-loser</CODE>, however, returns equivalent procedures each time, since
<A NAME="IDX196"></A>
the local state does not affect the value or side effects of the
procedures.



<PRE>
<TT>(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))                          ==&#62;  #t
(eqv? (gen-counter) (gen-counter))
                                       ==&#62;  #f
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))                          ==&#62;  #t
(eqv? (gen-loser) (gen-loser))
                                       ==&#62;  <EM>unspecified</EM>
</TT>
</PRE>

<P>
Objects of distinct types are never operationally equivalent, except
that false and the empty list are permitted to be identical, and the
character type need not be disjoint from other types.



<PRE>
<TT>(eqv? '() #f)                          ==&#62;  <EM>unspecified</EM>
(eqv? 57 #\A)                          ==&#62;  <EM>unspecified</EM>
</TT>
</PRE>

<P>
Since it is an error to modify constant objects (those returned by
literal expressions), implementations are permitted, though not
required, to share structure between constants where appropriate.  Thus
the value of <CODE>eqv?</CODE> on constants is sometimes
implementation-dependent.



<PRE>
<TT>(let ((x '(a)))
  (eqv? x x))                          ==&#62;  #t
(eqv? '(a) '(a))                       ==&#62;  <EM>unspecified</EM>
(eqv? "a" "a")                         ==&#62;  <EM>unspecified</EM>
(eqv? '(b) (cdr '(a b)))               ==&#62;  <EM>unspecified</EM>
</TT>
</PRE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM> 
The above definition of <CODE>eqv?</CODE> allows implementations latitude in
their treatment of procedures and literals:  implementations are free
to either detect or fail to detect that two procedures or two literals
are operationally equivalent to each other, and can decide whether or not to
merge representations of equivalent objects by using the same pointer or
bit pattern to represent both.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>eq?</B> <I>obj1 obj2</I>
<DD><A NAME="IDX197"></A>


<P>
<CODE>Eq?</CODE> is similar to <CODE>eqv?</CODE> except that in some cases it is
capable of discerning distinctions finer than those detectable by
<CODE>eqv?</CODE>.


<P>
<CODE>Eq?</CODE> and <CODE>eqv?</CODE> are guaranteed to have the same
behavior on symbols, booleans, the empty list, pairs, and non-empty
strings and vectors.  <CODE>Eq?</CODE>'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when <CODE>eqv?</CODE> would also return
true.  <CODE>Eq?</CODE> may also behave differently from <CODE>eqv?</CODE> on empty
vectors and empty strings.



<PRE>
<TT>(eq? 'a 'a)                            ==&#62;  #t
(eq? '(a) '(a))                        ==&#62;  <EM>unspecified</EM>
(eq? (list 'a) (list 'a))              ==&#62;  #f
(eq? "a" "a")                          ==&#62;  <EM>unspecified</EM>
(eq? "" "")                            ==&#62;  <EM>unspecified</EM>
(eq? '() '())                          ==&#62;  #t
(eq? 2 2)                              ==&#62;  <EM>unspecified</EM>
(eq? #\A #\A)                          ==&#62;  <EM>unspecified</EM>
(eq? car car)                          ==&#62;  #t
(let ((n (+ 2 3)))
  (eq? n n))                           ==&#62;  <EM>unspecified</EM>
(let ((x '(a)))
  (eq? x x))                           ==&#62;  #t
(let ((x '#()))
  (eq? x x))                           ==&#62;  #t
(let ((p (lambda (x) x)))
  (eq? p p))                           ==&#62;  #t
</TT>
</PRE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM> It will usually be possible to implement <CODE>eq?</CODE> much
more efficiently than <CODE>eqv?</CODE>, for example, as a simple pointer
comparison instead of as some more complicated operation.  One reason is
that it may not be possible to compute <CODE>eqv?</CODE> of two numbers in
constant time, whereas <CODE>eq?</CODE> implemented as pointer comparison will
always finish in constant time.  <CODE>Eq?</CODE> may be used like <CODE>eqv?</CODE>
in applications using procedures to implement objects with state since
it obeys the same constraints as <CODE>eqv?</CODE>.  @end quotation


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>equal?</B> <I>obj1 obj2</I>
<DD><A NAME="IDX198"></A>


<P>
<CODE>Equal?</CODE> recursively compares the contents of pairs, vectors, and
strings, applying <CODE>eqv?</CODE> on other objects such as numbers and symbols.
A rule of thumb is that objects are generally <CODE>equal?</CODE> if they print
the same.  <CODE>Equal?</CODE> may fail to terminate if its arguments are
circular data structures.



<PRE>
<TT>(equal? 'a 'a)                         ==&#62;  #t
(equal? '(a) '(a))                     ==&#62;  #t
(equal? '(a (b) c)
        '(a (b) c))                    ==&#62;  #t
(equal? "abc" "abc")                   ==&#62;  #t
(equal? 2 2)                           ==&#62;  #t
(equal? (make-vector 5 'a)
        (make-vector 5 'a))            ==&#62;  #t
(equal? (lambda (x) x)
        (lambda (y) y))                ==&#62;  <EM>unspecified</EM>
</TT>
</PRE>

</DL>



<H2><A NAME="SEC44">6.3 Pairs and lists</A></H2>

<P>
<A NAME="IDX199"></A>


<P>
A <EM>pair</EM> (sometimes called a <EM>dotted pair</EM>) is a
<A NAME="IDX200"></A>
<A NAME="IDX201"></A>
record structure with two fields called the car and cdr fields (for
historical reasons).  Pairs are created by the procedure <CODE>cons</CODE>.
<A NAME="IDX202"></A>
The car and cdr fields are accessed by the procedures <CODE>car</CODE> and
<A NAME="IDX203"></A>
<CODE>cdr</CODE>.  The car and cdr fields are assigned by the procedures
<A NAME="IDX204"></A>
<CODE>set-car!</CODE> and <CODE>set-cdr!</CODE>.
<A NAME="IDX205"></A>
<A NAME="IDX206"></A>


<P>
Pairs are used primarily to represent lists.  A list can be defined
recursively as either the empty list or a pair whose cdr is a list.  The
<A NAME="IDX207"></A>
objects in the car fields of successive pairs of a list are the elements
of the list.  For example, a two-element list is a pair whose car is the
first element and whose cdr is a pair whose car is the second element
and whose cdr is the empty list.  The length of a list is the number of
elements, which is the same as the number of pairs.


<P>
The empty list is a special object of its own type
(it is not a pair); it has no elements and its length is zero.


<P>
The most general notation (external representation) for Scheme pairs is
the "dotted" notation <SAMP>`(<VAR>c1</VAR> . <VAR>c2</VAR>)'</SAMP> where
<VAR>c1</VAR> is the value of the car field and <VAR>c2</VAR> is the value of the
cdr field.  For example <SAMP>`(4 . 5)'</SAMP> is a pair whose car is 4 and whose
cdr is 5.  Note that <SAMP>`(4 . 5)'</SAMP> is the external representation of a
pair, not an expression that evaluates to a pair.


<P>
A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list is written <TT>()</TT> .  For example,



<PRE>

(a b c d e)

</PRE>

<P>
and



<PRE>

(a . (b . (c . (d . (e . ())))))

</PRE>

<P>
are both representations of the same list of symbols.


<P>
A chain of pairs not ending in the empty list is called an
<EM>improper list</EM>.  Note that an improper list is not a list.
<A NAME="IDX208"></A>
The list and dotted notations can be combined to represent improper
lists:



<PRE>

(a b c . d)

</PRE>

<P>
is equivalent to



<PRE>

(a . (b . (c . d)))

</PRE>

<P>
Whether a given pair is a list depends upon what is stored in the cdr
field.  When the <CODE>set-cdr!</CODE> procedure is used, an object can be a
list one moment and not the next:



<PRE>

(define x (list 'a 'b 'c))
(define y x)
y                                      ==&#62;  (a b c)
(set-cdr! x 4)                         ==&#62;  <EM>unspecified</EM>
x                                      ==&#62;  (a . 4)
(eqv? x y)                             ==&#62;  #t
y                                      ==&#62;  (a . 4)

</PRE>

<P>
It is often convenient to speak of a homogeneous list of objects
of some particular data type, as for example <SAMP>`(1 2 3)'</SAMP> is a list of
integers.  To be more precise, suppose <VAR>D</VAR> is some data type.  (Any
predicate defines a data type consisting of those objects of which the
predicate is true.)  Then



<UL>

<LI>

The empty list is a list of <VAR>D</VAR>.
<LI>

If <VAR>list</VAR> is a list of <VAR>D</VAR>, then any pair whose cdr is
<VAR>list</VAR> and whose car is an element of the data type <VAR>D</VAR> is also a
list of <VAR>D</VAR>.
<LI>

There are no other lists of <VAR>D</VAR>.

</UL>

<P>
Within literal expressions and representations of objects read by the
<CODE>read</CODE> procedure, the forms <TT>'</TT>&#60;datum&#62;,
<A NAME="IDX209"></A>
<A NAME="IDX210"></A>
<TT>`</TT>&#60;datum&#62;, <TT>,</TT>&#60;datum&#62;, and
<A NAME="IDX211"></A>
<TT>,@</TT>&#60;datum&#62; denote two-element lists whose first elements are
the symbols <CODE>quote</CODE>, <CODE>quasiquote</CODE>, <CODE>unquote</CODE>, and
<A NAME="IDX212"></A>
<A NAME="IDX213"></A>
<A NAME="IDX214"></A>
<CODE>unquote-splicing</CODE>, respectively.  The second element in each case
<A NAME="IDX215"></A>
is &#60;datum&#62;.  This convention is supported so that arbitrary Scheme
programs may be represented as lists.  
 That is, according to Scheme's grammar, every
&#60;expression&#62; is also a &#60;datum&#62; (see section see section <A HREF="r3rs_9.html#SEC66">7.1.2 External representations</A>).
Among other things, this permits the use of the <CODE>read</CODE> procedure to
parse Scheme programs.  See section <A HREF="r3rs_5.html#SEC20">3.3 External representations</A>. 
 


<P>
<DL>
<DT><U>essential procedure:</U> <B>pair?</B> <I>obj</I>
<DD><A NAME="IDX216"></A>


<P>
<CODE>Pair?</CODE> returns <TT>#t</TT> if <VAR>obj</VAR> is a pair, and otherwise
<A NAME="IDX217"></A>
returns <TT>#f</TT>.



<PRE>
<TT>(pair? '(a . b))                       ==&#62;  #t
(pair? '(a b c))                       ==&#62;  #t
(pair? '())                            ==&#62;  #f
(pair? '#(a b))                        ==&#62;  #f
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>cons</B> <I>obj1 obj2</I>
<DD><A NAME="IDX218"></A>


<P>
Returns a newly allocated pair whose car is <VAR>obj1</VAR> and whose cdr is
<VAR>obj2</VAR>.  The pair is guaranteed to be different (in the sense of
<CODE>eqv?</CODE>) from every existing object.
<A NAME="IDX219"></A>



<PRE>
<TT>(cons 'a '())                          ==&#62;  (a)
(cons '(a) '(b c d))                   ==&#62;  ((a) b c d)
(cons "a" '(b c))                      ==&#62;  ("a" b c)
(cons 'a 3)                            ==&#62;  (a . 3)
(cons '(a b) 'c)                       ==&#62;  ((a b) . c)
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>car</B> <I>pair</I>
<DD><A NAME="IDX220"></A>


<P>
Returns the contents of the car field of <VAR>pair</VAR>.  Note that it is an
error to take the car of the empty list.



<PRE>
<TT>(car '(a b c))                         ==&#62;  a
(car '((a) b c d))                     ==&#62;  (a)
(car '(1 . 2))                         ==&#62;  1
(car '())                              ==&#62;  <EM>error</EM>
</TT>
</PRE>

<P>
 
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>cdr</B> <I>pair</I>
<DD><A NAME="IDX221"></A>


<P>
Returns the contents of the cdr field of <VAR>pair</VAR>.
Note that it is an error to take the cdr of the empty list.



<PRE>
<TT>(cdr '((a) b c d))                     ==&#62;  (b c d)
(cdr '(1 . 2))                         ==&#62;  2
(cdr '())                              ==&#62;  <EM>error</EM>
</TT>
</PRE>

<P>
 
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>set-car!</B> <I>pair obj</I>
<DD><A NAME="IDX222"></A>


<P>
  
Stores <VAR>obj</VAR> in the car field of <VAR>pair</VAR>.
The value returned by <CODE>set-car!</CODE> is unspecified.  


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>set-cdr!</B> <I>pair obj</I>
<DD><A NAME="IDX223"></A>


<P>
Stores <VAR>obj</VAR> in the cdr field of <VAR>pair</VAR>.
The value returned by <CODE>set-cdr!</CODE> is unspecified.  


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>caar</B> <I>pair</I>
<DD><A NAME="IDX224"></A>
<DT><U>essential procedure:</U> <B>cadr</B> <I>pair</I>
<DD><A NAME="IDX225"></A>


<P>
<DT><U>  ...:</U> <B> ...</B>
<DD><A NAME="IDX226"></A>


<P>
<DT><U>essential procedure:</U> <B>cdddar</B> <I>pair</I>
<DD><A NAME="IDX227"></A>
<DT><U>essential procedure:</U> <B>cddddr</B> <I>pair</I>
<DD><A NAME="IDX228"></A>


<P>
These procedures are compositions of <CODE>car</CODE> and <CODE>cdr</CODE>, where
for example <CODE>caddr</CODE> could be defined by
<A NAME="IDX229"></A>



<PRE>
<TT>(define caddr (lambda (x) (car (cdr (cdr x))))).
</TT>
</PRE>

<P>
Arbitrary compositions, up to four deep, are provided.  There are
twenty-eight of these procedures in all.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>null?</B> <I>obj</I>
<DD><A NAME="IDX230"></A>


<P>
Returns <TT>#t</TT> if <VAR>obj</VAR> is the empty list,
otherwise returns <TT>#f</TT>.  (In implementations in which the empty
list is the same as <TT>#f</TT>, <CODE>null?</CODE> will return <TT>#t</TT>
<A NAME="IDX231"></A>
if <VAR>obj</VAR> is <TT>#f</TT>.) 
 
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>list</B> <I><VAR>obj</VAR> ...</I>
<DD><A NAME="IDX232"></A>


<P>
Returns a list of its arguments.



<PRE>
<TT>(list 'a (+ 3 4) 'c)                   ==&#62;  (a 7 c)
(list)                                 ==&#62;  ()
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>length</B> <I>list</I>
<DD><A NAME="IDX233"></A>


<P>
Returns the length of <VAR>list</VAR>.



<PRE>
<TT>(length '(a b c))                      ==&#62;  3
(length '(a (b) (c d e)))              ==&#62;  3
(length '())                           ==&#62;  0
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>append</B> <I>list1 list2</I>
<DD><A NAME="IDX234"></A>
<DT><U>procedure:</U> <B>append</B> <I>list ...</I>
<DD><A NAME="IDX235"></A>


<P>
Returns a list consisting of the elements of the first <VAR>list</VAR>
followed by the elements of the other <VAR>list</VAR>s.



<PRE>
<TT>(append '(x) '(y))                     ==&#62;  (x y)
(append '(a) '(b c d))                 ==&#62;  (a b c d)
(append '(a (b)) '((c)))               ==&#62;  (a (b) (c))
</TT>
</PRE>

<P>
The resulting list is always newly allocated, except that it shares
structure with the last <VAR>list</VAR> argument.  The last argument may
actually be any object; an improper list results if it is not a proper
list.  



<PRE>
<TT>(append '(a b) '(c . d))               ==&#62;  (a b c . d)
(append '() 'a)                        ==&#62;  a
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>reverse</B> <I>list</I>
<DD><A NAME="IDX236"></A>


<P>
Returns a newly allocated list consisting of the elements of <VAR>list</VAR>
in reverse order.



<PRE>
<TT>(reverse '(a b c))                     ==&#62;  (c b a)
(reverse '(a (b c) d (e (f))))  
          ==&#62;  ((e (f)) d (b c) a)
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>list-tail</B> <I>list <VAR>k</VAR></I>
<DD><A NAME="IDX237"></A>


<P>
Returns the sublist of <VAR>list</VAR> obtained by omitting the first <VAR>k</VAR>
elements.
<CODE>List-tail</CODE> could be defined by
<A NAME="IDX238"></A>



<PRE>
<TT>(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))
</TT>
</PRE>

<P>
 
</DL>


<P>
<DL>
<DT><U>procedure:</U> <B>list-ref</B> <I>list <VAR>k</VAR></I>
<DD><A NAME="IDX239"></A>


<P>
Returns the <VAR>k</VAR>th element of <VAR>list</VAR>.  (This is the same
as the car of <TT>(list-tail <VAR>list</VAR> <VAR>k</VAR>)</TT>.)



<PRE>
<TT>(list-ref '(a b c d) 2)                ==&#62;  c
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>last-pair</B> <I>list</I>
<DD><A NAME="IDX240"></A>


<P>
Returns the last pair in the nonempty, possibly improper, list <VAR>list</VAR>.
<CODE>Last-pair</CODE> could be defined by
<A NAME="IDX241"></A>



<PRE>
<TT>(define last-pair
  (lambda (x)
    (if (pair? (cdr x))
        (last-pair (cdr x))
        x)))
</TT>
</PRE>

<P>
 
 
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>memq</B> <I>obj list</I>
<DD><A NAME="IDX242"></A>
<DT><U>essential procedure:</U> <B>memv</B> <I>obj list</I>
<DD><A NAME="IDX243"></A>
<DT><U>essential procedure:</U> <B>member</B> <I>obj list</I>
<DD><A NAME="IDX244"></A>


<P>
These procedures return the first sublist of <VAR>list</VAR> whose car is
<VAR>obj</VAR>.  If <VAR>obj</VAR> does not occur in <VAR>list</VAR>, <TT>#f</TT>
(n.b.: not the empty list) is returned.  <CODE>Memq</CODE> uses <CODE>eq?</CODE> to
<A NAME="IDX245"></A>
<A NAME="IDX246"></A>
compare <VAR>obj</VAR> with the elements of <VAR>list</VAR>, while <CODE>memv</CODE> uses
<A NAME="IDX247"></A>
<CODE>eqv?</CODE> and <CODE>member</CODE> uses <CODE>equal?</CODE>.
<A NAME="IDX248"></A>
<A NAME="IDX249"></A>



<PRE>
<TT>(memq 'a '(a b c))                     ==&#62;  (a b c)
(memq 'b '(a b c))                     ==&#62;  (b c)
(memq 'a '(b c d))                     ==&#62;  #f
(memq (list 'a) '(b (a) c))            ==&#62;  #f
(member (list 'a)
        '(b (a) c))                    ==&#62;  ((a) c)
(memq 101 '(100 101 102))              ==&#62;  <EM>unspecified</EM>
(memv 101 '(100 101 102))              ==&#62;  (101 102)
</TT>
</PRE>

<P>
 
 
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>assq</B> <I>obj alist</I>
<DD><A NAME="IDX250"></A>
<DT><U>essential procedure:</U> <B>assv</B> <I>obj alist</I>
<DD><A NAME="IDX251"></A>
<DT><U>essential procedure:</U> <B>assoc</B> <I>obj alist</I>
<DD><A NAME="IDX252"></A>


<P>
<VAR>Alist</VAR> (for "association list") must be a list of
pairs.  These procedures find the first pair in <VAR>alist</VAR> whose car field is <VAR>obj</VAR>,
and returns that pair.  If no pair in <VAR>alist</VAR> has <VAR>obj</VAR> as its
car, <TT>#f</TT> is returned.  <CODE>Assq</CODE> uses <CODE>eq?</CODE> to compare <VAR>obj</VAR>
<A NAME="IDX253"></A>
with the car fields of the pairs in <VAR>alist</VAR>, while <CODE>assv</CODE> uses
<A NAME="IDX254"></A>
<CODE>eqv?</CODE> and <CODE>assoc</CODE> uses <CODE>equal?</CODE>.
<A NAME="IDX255"></A>



<PRE>
<TT>(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                            ==&#62;  (a 1)
(assq 'b e)                            ==&#62;  (b 2)
(assq 'd e)                            ==&#62;  #f
(assq (list 'a) '(((a)) ((b)) ((c))))
                                       ==&#62;  #f
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                                       ==&#62;  ((a))
(assq 5 '((2 3) (5 7) (11 13)))    
                                       ==&#62;  <EM>unspecified</EM>
(assv 5 '((2 3) (5 7) (11 13)))    
                                       ==&#62;  (5 7)
</TT>
</PRE>


<BLOCKQUOTE>
<P>
<EM>Note:</EM>
Although they are ordinarily used as predicates,
<CODE>memq</CODE>, <CODE>memv</CODE>, <CODE>member</CODE>, <CODE>assq</CODE>, <CODE>assv</CODE>, and <CODE>assoc</CODE> do not
have question marks in their names because they return useful values rather
than just <TT>#t</TT> or <TT>#f</TT>.
</BLOCKQUOTE>

</DL>



<H2><A NAME="SEC45">6.4 Symbols</A></H2>

<P>
<A NAME="IDX256"></A>


<P>
Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of <CODE>eqv?</CODE>) if and only if their
<A NAME="IDX257"></A>
names are spelled the same way.  This is exactly the property needed to
represent identifiers in programs, and so most
<A NAME="IDX258"></A>
implementations of Scheme use them internally for that purpose.  Symbols
are useful for many other applications; for instance, they may be used
the way enumerated values are used in Pascal.


<P>
The rules for writing a symbol are exactly the same as the rules for
writing an identifier; see sections section <A HREF="r3rs_4.html#SEC14">2.1 Identifiers</A>
and section <A HREF="r3rs_9.html#SEC65">7.1.1 Lexical structure</A>.


<P>
It is guaranteed that any symbol that has been returned as part of
a literal expression, or read using the <CODE>read</CODE> procedure, and
<A NAME="IDX259"></A>
subsequently written out using the <CODE>write</CODE> procedure, will read back
<A NAME="IDX260"></A>
in as the identical symbol (in the sense of <CODE>eqv?</CODE>).  The
<CODE>string-&#62;symbol</CODE> procedure, however, can create symbols for
<A NAME="IDX261"></A>
which this write/read invariance may not hold because their names
contain special characters or letters in the non-standard case.



<BLOCKQUOTE>
<P>
<EM>Note:</EM>
Some implementations of Scheme have a feature known as "slashification"
in order to guarantee write/read invariance for all symbols, but
historically the most important use of this feature has been to
compensate for the lack of a string data type.


<P>
Some implementations also have "uninterned symbols", which
defeat write/read invariance even in implementations with slashification,
and also generate exceptions to the rule that two symbols are the same
if and only if their names are spelled the same.
</BLOCKQUOTE>

<P>
<DL>
<DT><U>essential procedure:</U> <B>symbol?</B> <I>obj</I>
<DD><A NAME="IDX262"></A>


<P>
Returns <TT>#t</TT> if <VAR>obj</VAR> is a symbol, otherwise returns <TT>#f</TT>.



<PRE>
<TT>(symbol? 'foo)                         ==&#62;  #t
(symbol? (car '(a b)))                 ==&#62;  #t
(symbol? "bar")                        ==&#62;  #f
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>symbol-&#62;string</B> <I>symbol</I>
<DD><A NAME="IDX263"></A>


<P>
Returns the name of <VAR>symbol</VAR> as a string.  If the symbol was part of
an object returned as the value of a literal expression
(section see section <A HREF="r3rs_6.html#SEC24">4.1.2 Literal expressions</A>) or by a call to the <CODE>read</CODE> procedure,
and its name contains alphabetic characters, then the string returned
will contain characters in the implementation's preferred standard
case--some implementations will prefer upper case, others lower case.
If the symbol was returned by <CODE>string-&#62;symbol</CODE>, the case of
characters in the string returned will be the same as the case in the
string that was passed to <CODE>string-&#62;symbol</CODE>.  It is an error
to apply mutation procedures like <CODE>string-set!</CODE> to strings returned
<A NAME="IDX264"></A>
by this procedure.


<P>
The following examples assume that the implementation's standard case is
lower case:



<PRE>
<TT>(symbol-&#62;string 'flying-fish)     
                                       ==&#62;  "flying-fish"
(symbol-&#62;string 'Martin)               ==&#62;  "martin"
(symbol-&#62;string
   (string-&#62;symbol "Malvina"))     
                                       ==&#62;  "Malvina"
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>string-&#62;symbol</B> <I>string</I>
<DD><A NAME="IDX265"></A>


<P>
Returns the symbol whose name is <VAR>string</VAR>.  This procedure can
create symbols with names containing special characters or letters in
the non-standard case, but it is usually a bad idea to create such
symbols because in some implementations of Scheme they cannot be read as
themselves.  See <CODE>symbol-&#62;string</CODE>.
<A NAME="IDX266"></A>


<P>
The following examples assume that the implementation's standard case is
lower case:



<PRE>
<TT>(eq? 'mISSISSIppi 'mississippi)  
          ==&#62;  #t
(string-&#62;symbol "mISSISSIppi")  
          ==&#62;
  </TT>the symbol with name "mISSISSIppi"
(eq? 'bitBlt (string-&#62;symbol "bitBlt"))     
          ==&#62;  #f
(eq? 'JollyWog
     (string-&#62;symbol
       (symbol-&#62;string 'JollyWog)))  
          ==&#62;  #t
(string=? "K. Harper, M.D."
          (symbol-&#62;string
            (string-&#62;symbol "K. Harper, M.D.")))  
          ==&#62;  #t

</PRE>

</DL>



<H2><A NAME="SEC46">6.5 Numbers</A></H2>

<P>
<A NAME="IDX267"></A>


<P>
<A NAME="IDX268"></A>


<P>
Numerical computation has traditionally been neglected by the Lisp
community.  Until Common Lisp there has been no carefully thought out
strategy for organizing numerical computation, and with the exception of
the MacLisp system <A HREF="r3rs_12.html#BIB28">[Pitman83]</A> there has been little effort to
execute numerical code efficiently.  We applaud the excellent work of
the Common Lisp committee and we accept many of their recommendations.
In some ways we simplify and generalize their proposals in a manner
consistent with the purposes of Scheme.


<P>
Scheme's numerical operations treat numbers as abstract data, as
independent of their representation as is possible.  Thus, the casual user
should be able to write simple programs without having to know that the
implementation may use fixed-point, floating-point, and perhaps other
representations for his data.  Unfortunately, this illusion of uniformity
can be sustained only approximately--the implementation of numbers will
leak out of its abstraction whenever the user must be in control of
precision, or accuracy, or when he must construct especially efficient
computations.  Thus the language must also provide escape mechanisms so
that a sophisticated programmer can exercise more control over the
execution of his code and the representation of his data when necessary.


<P>
It is important to distinguish between the abstract numbers, their
machine representations, and their written representations.  We will use
mathematical terms <I>number</I>, <I>complex</I>, <I>real</I>,
<I>rational</I>, and <I>integer</I> for properties of the abstract
numbers, the names <I>fixnum</I>, <I>bignum</I>, <I>ratnum</I>, and
<I>flonum</I> for machine representations, and the names
<I>int</I>, <I>fix</I>, <I>flo</I>, <I>sci</I>, <I>rat</I>,
<I>polar</I>, and <I>rect</I> for input/output formats. 


<P>
 


<H3><A NAME="SEC47">6.5.1 Numbers</A></H3>

<P>
<A NAME="IDX269"></A>


<P>
A Scheme system provides data of type <I>number</I>, which is the most
general numerical type supported by that system.  <I>Number</I> is likely
to be a complicated union type implemented in terms of <I>fixnum</I>s,
<I>bignum</I>s, <I>flonum</I>s, and so forth, but this should not be
apparent to a naive user.  What the user should see is that the usual
operations on numbers produce the mathematically expected results, within
the limits of the implementation.  Thus if the user divides the exact
number 3 by the exact number 2, he should get something like 1.5 (or the
exact fraction 3/2).  If he adds that result to itself, and the
implementation is good enough, he should get an exact 3.


<P>
Mathematically, numbers may be arranged into a tower of subtypes with 
projections and injections relating adjacent levels of the tower:


<center>
<P>
 
</center>

<BLOCKQUOTE>
<DL COMPACT>

<DT><I>number</I>
<DD>
<DT><I>complex</I>
<DD>
<DT><I>real</I>
<DD>
<DT><I>rational</I>
<DD>
<DT><I>integer</I>
<DD>
</DL>
</BLOCKQUOTE>

<P>
 


<P>
We impose a uniform rule of downward coercion--a number of one type is
also of a lower type if the injection (up) of the projection (down) of a
number leaves the number unchanged.  Since this tower is a genuine
mathematical structure, Scheme provides predicates and procedures to access
the tower.


<P>
Not all implementations of Scheme must provide the whole tower,
but they must implement a coherent subset consistent with both the
purposes of the implementation and the spirit of the Scheme language. 
 
 


<H3><A NAME="SEC48">6.5.2 Exactness</A></H3>

<P>
<A NAME="IDX270"></A>


<P>
 
Numbers are either <I>exact</I> or <I>inexact</I>.  A number is
<I>exact</I> if it was derived from <I>exact</I> numbers using only
<I>exact</I> operations.  A number is <I>inexact</I> if it models a
quantity (e.g., a measurement) known only approximately, if it was
derived using <I>inexact</I> ingredients, or if it was derived using
<I>inexact</I> operations.
Thus <I>inexact</I>ness is a contagious property of a number.  Some
operations, such as the square root (of non-square numbers), must be
<I>inexact</I> because of the finite precision of our representations.


<P>
Other operations are inexact because of implementation requirements.  We
emphasize that exactness is independent of the position of the number on
the tower.  It is perfectly possible to have an <I>inexact</I>
<I>integer</I> or an <I>exact</I> <I>real</I>; 355/113 may be an
<I>exact</I> <I>rational</I> or it may be an <I>inexact</I>
<I>rational</I> approximation to pi, depending on the application.


<P>
Operationally, it is the system's responsibility to combine <I>exact</I>
numbers using exact methods, such as infinite precision integer and
rational arithmetic, where possible.  An implementation may not be able to
do this (if it does not use infinite precision integers and rationals), but
if a number becomes <I>inexact</I> for implementation reasons there is
likely to be an important error condition, such as integer overflow, to be
reported.  Arithmetic on <I>inexact</I> numbers is not so constrained.  The
system may use floating point and other ill-behaved representation
strategies for <I>inexact</I> numbers.  This is not to say that
implementors need not use the best known algorithms for <I>inexact</I>
computations--only that approximate methods of high quality are allowed.
In a system that cannot explicitly distinguish exact from <I>inexact</I>
numbers the system must do its best to maintain precision.  Scheme systems
must not burden users with numerical operations described in terms of
hardware and operating-system dependent representations such as
<I>fixnum</I> and <I>flonum</I>, however, because these representation
issues are hardly ever germane to the user's problems.


<P>
We highly recommend that the IEEE 32-bit and 64-bit floating-point
standards be adopted for implementations that use floating-point
representations internally.  To minimize loss of precision we adopt the
following rules: If an implementation uses several different sizes of
floating-point formats, the results of any operation with a floating-point
result must be expressed in the largest format used to express any of the
floating-point arguments to that operation.  It is desirable (but not
required) for potentially irrational operations such as <CODE>sqrt</CODE>, when
<A NAME="IDX271"></A>
applied to <I>exact</I> arguments, to produce <I>exact</I> answers whenever
possible (for example the square root of an exact 4 ought to be an exact
2).  If an <I>exact</I> number (or an <I>inexact</I> number represented as
a <I>fixnum</I>, a <I>bignum</I>, or a <I>ratnum</I>) is operated upon so
as to produce an <I>inexact</I> result (as by <CODE>sqrt</CODE>), and if the
result is represented as a <I>flonum</I>, then the largest available
<I>flonum</I> format must be used; but if the result is expressed as a
<I>ratnum</I> then the rational approximation must have at least as much
precision as the largest available <I>flonum</I>.




<H3><A NAME="SEC49">6.5.3 Number syntax</A></H3>

<P>
<A NAME="IDX272"></A>


<P>
Scheme allows the traditional ways of writing numerical constants,
though any particular implementation may support only some of them.
These syntaxes are intended to be purely notational; any kind of number
may be written in any form that the user deems convenient.  Of course,
writing 1/7 as a limited-precision decimal fraction will not express the
number exactly, but this approximate form of expression may be just what
the user wants to see.


<P>
The syntax of numbers is described formally in
section <A HREF="r3rs_9.html#SEC65">7.1.1 Lexical structure</A>.  See section <A HREF="r3rs_8.html#SEC52">6.5.6 Formats</A> for
many examples of representations of numbers.


<P>
A numerical constant may be represented in binary, octal, decimal, or
hex by the use of a radix prefix.  The radix prefixes are <SAMP>`#b'</SAMP> (binary), <SAMP>`#o'</SAMP> (octal), <SAMP>`#d'</SAMP> (decimal), and <SAMP>`#x'</SAMP> (hex).  With
<A NAME="IDX273"></A>
<A NAME="IDX274"></A>
<A NAME="IDX275"></A>
<A NAME="IDX276"></A>
no radix prefix, a number is assumed to be expressed in decimal.


<P>
A numerical constant may be specified to be either <I>exact</I> or
<I>inexact</I> by a prefix.  The prefixes are <SAMP>`#e'</SAMP>
<A NAME="IDX277"></A>
for exact, and <SAMP>`#i'</SAMP> for inexact.  An exactness prefix
<A NAME="IDX278"></A>
may appear before or after any radix prefix that is used.  If the
representation of a numerical constant has no exactness prefix, the
constant may be assumed to be exact or inexact at the discretion of the
implementation, except that integers expressed without decimal points
and without use of exponential notation are assumed exact.


<P>
In systems with both single and double precision <I>flonum</I>s we may
want to specify which size we want to use to represent a constant
internally.  For example, we may want a constant that has the value of
pi rounded to the single precision length, or we might want a long
number that has the value 6/10.  In either case, we are specifying an
explicit way to represent an <I>inexact</I> number.  For this purpose,
we may express a number with a prefix that indicates short or long
<I>flonum</I> representation:
<A NAME="IDX279"></A>
<A NAME="IDX280"></A>



<PRE>

#S3.14159265358979
       Round to short --- 3.141593
#L.6
       Extend to long --- .600000000000000

</PRE>



<H3><A NAME="SEC50">6.5.4 Numerical operations</A></H3>

<P>
<A NAME="IDX281"></A>


<P>
The reader is referred to section <A HREF="r3rs_3.html#SEC11">1.3.3 Entry format</A> for a summary of
the naming conventions used to specify restrictions on the types of
arguments to numerical routines.


<P>
<DL>
<DT><U>essential procedure:</U> <B>number?</B> <I>obj</I>
<DD><A NAME="IDX282"></A>
<DT><U>essential procedure:</U> <B>complex?</B> <I>obj</I>
<DD><A NAME="IDX283"></A>
<DT><U>essential procedure:</U> <B>real?</B> <I>obj</I>
<DD><A NAME="IDX284"></A>
<DT><U>essential procedure:</U> <B>rational?</B> <I>obj</I>
<DD><A NAME="IDX285"></A>
<DT><U>essential procedure:</U> <B>integer?</B> <I>obj</I>
<DD><A NAME="IDX286"></A>


<P>
These numerical type predicates can be applied to any kind of argument,
including non-numbers.
They return true if the object is of the named type.  In general, if a type
predicate is true of a number then all higher type predicates are also true
of that number.  Not every system supports all of these types; for example,
it is entirely possible to have a Scheme system that has only
<I>integer</I>s.  Nonetheless every implementation of Scheme must have all
of these predicates.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>zero?</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX287"></A>
<DT><U>essential procedure:</U> <B>positive?</B> <I><VAR>x</VAR></I>
<DD><A NAME="IDX288"></A>
<DT><U>essential procedure:</U> <B>negative?</B> <I><VAR>x</VAR></I>
<DD><A NAME="IDX289"></A>
<DT><U>essential procedure:</U> <B>odd?</B> <I><VAR>n</VAR></I>
<DD><A NAME="IDX290"></A>
<DT><U>essential procedure:</U> <B>even?</B> <I><VAR>n</VAR></I>
<DD><A NAME="IDX291"></A>
<DT><U>essential procedure:</U> <B>exact?</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX292"></A>
<DT><U>essential procedure:</U> <B>inexact?</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX293"></A>


<P>
These numerical predicates test a number for a particular property, returning
<TT>#t</TT> or <TT>#f</TT>.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>=</B> <I>z1 z2</I>
<DD><A NAME="IDX294"></A>
<DT><U>essential procedure:</U> <B>&#60;</B> <I>x1 x2</I>
<DD><A NAME="IDX295"></A>
<DT><U>essential procedure:</U> <B>&#62;</B> <I>x1 x2</I>
<DD><A NAME="IDX296"></A>
<DT><U>essential procedure:</U> <B>&#60;=</B> <I>x1 x2</I>
<DD><A NAME="IDX297"></A>
<DT><U>essential procedure:</U> <B>&#62;=</B> <I>x1 x2</I>
<DD><A NAME="IDX298"></A>


<P>
Some implementations allow these procedures to take many arguments, to
facilitate range checks.  These procedures return <TT>#t</TT> if their
arguments are (respectively): numerically equal, monotonically
increasing, monotonically decreasing, monotonically nondecreasing, or
monotonically nonincreasing.  Warning: on <I>inexact</I> numbers the
equality tests will give unreliable results, and the other numerical
comparisons will be useful only heuristically; when in doubt, consult a
numerical analyst.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>max</B> <I>x1 x2</I>
<DD><A NAME="IDX299"></A>
<DT><U>procedure:</U> <B>max</B> <I>x1 x2 ...</I>
<DD><A NAME="IDX300"></A>
<DT><U>essential procedure:</U> <B>min</B> <I>x1 x2</I>
<DD><A NAME="IDX301"></A>
<DT><U>procedure:</U> <B>min</B> <I>x1 x2 ...</I>
<DD><A NAME="IDX302"></A>


<P>
These procedures return the maximum or minimum of their arguments.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>+</B> <I>z1 z2</I>
<DD><A NAME="IDX303"></A>
<DT><U>procedure:</U> <B>+</B> <I>z1 ...</I>
<DD><A NAME="IDX304"></A>
<DT><U>essential procedure:</U> <B>*</B> <I>z1 z2</I>
<DD><A NAME="IDX305"></A>
<DT><U>procedure:</U> <B>*</B> <I>z1 ...</I>
<DD><A NAME="IDX306"></A>


<P>
These procedures return the sum or product of their arguments.



<PRE>
<TT>(+ 3 4)                                ==&#62;  7
(+ 3)                                  ==&#62;  3
(+)                                    ==&#62;  0
(* 4)                                  ==&#62;  4
(*)                                    ==&#62;  1
</TT>
</PRE>

<P>
 
 
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>-</B> <I>z1 z2</I>
<DD><A NAME="IDX307"></A>
<DT><U>procedure:</U> <B>-</B> <I>z1 z2 ...</I>
<DD><A NAME="IDX308"></A>
<DT><U>essential procedure:</U> <B>/</B> <I>z1 z2</I>
<DD><A NAME="IDX309"></A>
<DT><U>procedure:</U> <B>/</B> <I>z1 z2 ...</I>
<DD><A NAME="IDX310"></A>


<P>
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left.  With one argument,
however, they return the additive or multiplicative inverse of their argument.



<PRE>
<TT>(- 3 4)                                ==&#62;  -1
(- 3 4 5)                              ==&#62;  -6
(- 3)                                  ==&#62;  -3
(/ 3 4 5)                              ==&#62;  3/20
(/ 3)                                  ==&#62;  1/3
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>abs</B> <I>z</I>
<DD><A NAME="IDX311"></A>


<P>
<CODE>Abs</CODE> returns the magnitude of its argument.  
<A NAME="IDX312"></A>



<PRE>
<TT>(abs -7)                               ==&#62;  7
(abs -3+4i)                            ==&#62;  5
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>quotient</B> <I>n1 n2</I>
<DD><A NAME="IDX313"></A>
<DT><U>essential procedure:</U> <B>remainder</B> <I>n1 n2</I>
<DD><A NAME="IDX314"></A>
<DT><U>procedure:</U> <B>modulo</B> <I>n1 n2</I>
<DD><A NAME="IDX315"></A>


<P>
These are intended to implement number-theoretic (integer)
division: For positive integers <VAR>n1</VAR> and <VAR>n2</VAR>, if <VAR>n3</VAR> and
<VAR>n4</VAR> are integers such that <VAR>n1</VAR>=<VAR>n2</VAR><VAR>n3</VAR>+<VAR>n4</VAR> and
0&#60;= <VAR>n4</VAR>&#60;<VAR>n2</VAR>, then



<PRE>
<TT>(quotient <VAR>n1</VAR> <VAR>n2</VAR>)                       ==&#62;  <VAR>n3</VAR>
(remainder <VAR>n1</VAR> <VAR>n2</VAR>)                      ==&#62;  <VAR>n4</VAR>
(modulo <VAR>n1</VAR> <VAR>n2</VAR>)                         ==&#62;  <VAR>n4</VAR>
</TT>
</PRE>

<P>
For all integers <VAR>n1</VAR> and <VAR>n2</VAR> with <VAR>n2</VAR> not equal to 0,



<PRE>
<TT>(= <VAR>n1</VAR> (+ (* <VAR>n2</VAR> (quotient <VAR>n1</VAR> <VAR>n2</VAR>))
              (remainder <VAR>n1</VAR> <VAR>n2</VAR>)))
                                       ==&#62;  #t
</TT>
</PRE>

<P>
The value returned by <CODE>quotient</CODE> always has the sign of the product of
<A NAME="IDX316"></A>
its arguments.  <CODE>Remainder</CODE> and <CODE>modulo</CODE> differ on negative arguments--the
<A NAME="IDX317"></A>
<A NAME="IDX318"></A>
<CODE>remainder</CODE> always has the sign of the dividend, the <CODE>modulo</CODE>
always has the sign of the divisor:



<PRE>
<TT>(modulo 13 4)                          ==&#62;  1
(remainder 13 4)                       ==&#62;  1

(modulo -13 4)                         ==&#62;  3
(remainder -13 4)                      ==&#62;  -1

(modulo 13 -4)                         ==&#62;  -3
(remainder 13 -4)                      ==&#62;  1

(modulo -13 -4)                        ==&#62;  -1
(remainder -13 -4)                     ==&#62;  -1
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>numerator</B> <I><VAR>q</VAR></I>
<DD><A NAME="IDX319"></A>
<DT><U>procedure:</U> <B>denominator</B> <I><VAR>q</VAR></I>
<DD><A NAME="IDX320"></A>


<P>
These procedures return the numerator or denominator of their argument.



<PRE>
<TT>(numerator (/ 6 4))                    ==&#62;  3
(denominator (/ 6 4))                  ==&#62;  2
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>gcd</B> <I>n1 ...</I>
<DD><A NAME="IDX321"></A>
<DT><U>procedure:</U> <B>lcm</B> <I>n1 ...</I>
<DD><A NAME="IDX322"></A>


<P>
These procedures return the greatest common divisor or least common
multiple of their arguments. The result is always non-negative.



<PRE>
<TT>(gcd 32 -36)                           ==&#62;  4
(gcd)                                  ==&#62;  0
(lcm 32 -36)                           ==&#62;  288
(lcm)                                  ==&#62;  1
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>floor</B> <I>x</I>
<DD><A NAME="IDX323"></A>
<DT><U>procedure:</U> <B>ceiling</B> <I>x</I>
<DD><A NAME="IDX324"></A>
<DT><U>procedure:</U> <B>truncate</B> <I>x</I>
<DD><A NAME="IDX325"></A>
<DT><U>procedure:</U> <B>round</B> <I>x</I>
<DD><A NAME="IDX326"></A>
<DT><U>procedure:</U> <B>rationalize</B> <I>x y</I>
<DD><A NAME="IDX327"></A>
<DT><U>procedure:</U> <B>rationalize</B> <I>x</I>
<DD><A NAME="IDX328"></A>


<P>
These procedures create integers and rationals.  Their results are
<I>exact</I> if and only if their arguments are <I>exact</I>.


<P>
<CODE>Floor</CODE> returns the largest integer not larger than <VAR>x</VAR>.
<A NAME="IDX329"></A>
<CODE>Ceiling</CODE> returns the smallest integer not smaller than <VAR>x</VAR>.
<A NAME="IDX330"></A>
<CODE>Truncate</CODE> returns the integer of maximal absolute value not larger
<A NAME="IDX331"></A>
than the absolute value of <VAR>x</VAR>.  <CODE>Round</CODE> returns the closest
<A NAME="IDX332"></A>
integer to <VAR>x</VAR>, rounding to even when <VAR>x</VAR> is halfway between two
integers.  With two arguments, <CODE>rationalize</CODE> produces the rational
<A NAME="IDX333"></A>
number with smallest denominator differing from <VAR>x</VAR> by no more than
<VAR>y</VAR>.  With one argument, <CODE>rationalize</CODE> produces the best rational
approximation to <VAR>x</VAR>, preserving all of the precision in its
representation.



<BLOCKQUOTE>
<P>
<EM>Note:</EM>
<CODE>Round</CODE> rounds to even for consistency with the rounding
modes required by the IEEE floating point standard.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>exp</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX334"></A>
<DT><U>procedure:</U> <B>log</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX335"></A>
<DT><U>procedure:</U> <B>sin</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX336"></A>
<DT><U>procedure:</U> <B>cos</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX337"></A>
<DT><U>procedure:</U> <B>tan</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX338"></A>
<DT><U>procedure:</U> <B>asin</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX339"></A>
<DT><U>procedure:</U> <B>acos</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX340"></A>
<DT><U>procedure:</U> <B>atan</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX341"></A>
<DT><U>procedure:</U> <B>atan</B> <I><VAR>y</VAR> <VAR>x</VAR></I>
<DD><A NAME="IDX342"></A>


<P>
These procedures are part of every implementation that supports real
numbers; they compute the usual transcendental functions.  <CODE>Log</CODE>
<A NAME="IDX343"></A>
computes the natural logarithm of <VAR>z</VAR> (not the base 10 logarithm).
<CODE>Asin</CODE>, <CODE>acos</CODE>, and <CODE>atan</CODE> compute arcsine (sin^-1),
<A NAME="IDX344"></A>
<A NAME="IDX345"></A>
<A NAME="IDX346"></A>
arccosine (cos^-1), and arctangent (tan^-1), respectively.
The two-argument variant of <CODE>atan</CODE> computes <TT>(angle
(make-rectangular <VAR>x</VAR> <VAR>y</VAR>))</TT> (see below), even in implementations
that don't support complex numbers.


<P>
In general, the mathematical functions log, arcsine, arccosine, and
arctangent are multiply defined.
For nonzero real x, the value of log x is defined to be
the one whose imaginary part lies in the range -pi (exclusive) to
pi (inclusive).  log 0 is undefined.  The value of log z when
<VAR>z</VAR> is complex is defined according to the formula


<center>
<P>
 log z = log magnitude(z) + i --&#62; angle (z)
</center>


<P>
With log defined this way, the values of sin^-1 z, cos^-1 z,
and tan^-1 z are according to the following formulae:


<center>
<P>
 sin^-1 z = -i log (i z + sqrt1 - z^2)
</center>


<center>
<P>
 cos^-1 z = -i log (z + i sqrt1 - z^2)
</center>


<center>
<P>
 tan^-1 z = -i log ( (1 + i z) sqrt1/(1 + z^2) )
</center>


<P>
The above specification follows <A HREF="r3rs_12.html#BIB43">[CLtL]</A>, which in turn
follows <A HREF="r3rs_12.html#BIB26">[Penfield81]</A>; refer to these sources for more detailed
discussion of branch cuts, boundary conditions, and implementation of
these functions.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>sqrt</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX347"></A>


<P>
Returns the principal square root of <VAR>z</VAR>.  The result will have
either positive real part, or zero real part and non-negative imaginary
part.
</DL>


<P>
<DL>
<DT><U>procedure:</U> <B>expt</B> <I>z1 z2</I>
<DD><A NAME="IDX348"></A>


<P>
Returns <VAR>z1</VAR> raised to the power <VAR>z2</VAR>:


<center>
<P>
 z_1^z_2 = e^z_2 log z_1
</center>


<P>
0^0 is defined to be equal to 1.
</DL>


<P>
<DL>
<DT><U>procedure:</U> <B>make-rectangular</B> <I>x1 x2</I>
<DD><A NAME="IDX349"></A>
<DT><U>procedure:</U> <B>make-polar</B> <I>x3 x4</I>
<DD><A NAME="IDX350"></A>
<DT><U>procedure:</U> <B>real-part</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX351"></A>
<DT><U>procedure:</U> <B>imag-part</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX352"></A>
<DT><U>procedure:</U> <B>magnitude</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX353"></A>
<DT><U>procedure:</U> <B>angle</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX354"></A>


<P>
These procedures are part of every implementation that supports complex
numbers.  Suppose <VAR>x1</VAR>, <VAR>x2</VAR>, <VAR>x3</VAR>, and <VAR>x4</VAR> are
real numbers and <VAR>z</VAR> is a complex number such that
 


<center>
<P>
  <VAR>z</VAR> = <VAR>x1</VAR> + <VAR>x2</VAR>i = <VAR>x3</VAR> . e^i <VAR>x4</VAR>
</center>


<P>
Then <CODE>make-rectangular</CODE> and <CODE>make-polar</CODE> return <VAR>z</VAR>,
<A NAME="IDX355"></A>
<A NAME="IDX356"></A>
<CODE>real-part</CODE> returns <VAR>x1</VAR>, <CODE>imag-part</CODE> returns <VAR>x2</VAR>,
<A NAME="IDX357"></A>
<A NAME="IDX358"></A>
<CODE>magnitude</CODE> returns <VAR>x3</VAR>, and <CODE>angle</CODE> returns <VAR>x4</VAR>.
<A NAME="IDX359"></A>
<A NAME="IDX360"></A>
In the case of <CODE>angle</CODE>, whose value is not uniquely determined by
the preceding rule, the value returned will be the one in the range
-pi (exclusive) to pi (inclusive).



<BLOCKQUOTE>
<P>
<EM>Note:</EM> <CODE>Magnitude</CODE> is the same as <CODE>abs</CODE>, but <CODE>abs</CODE>
must be present in all implementations, whereas <CODE>magnitude</CODE> will
only be present in implementations that support complex numbers.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>exact-&#62;inexact</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX361"></A>
<DT><U>procedure:</U> <B>inexact-&#62;exact</B> <I><VAR>z</VAR></I>
<DD><A NAME="IDX362"></A>


<P>
<CODE>Exact-&#62;inexact</CODE> returns an <I>inexact</I> representation of <VAR>z</VAR>,
<A NAME="IDX363"></A>
which is a fairly harmless thing to do.  <CODE>Inexact-&#62;exact</CODE> returns an
<A NAME="IDX364"></A>
<I>exact</I> representation of <VAR>z</VAR>.  Since the law of "garbage in,
garbage out" remains in force, <CODE>inexact-&#62;exact</CODE> should not be used
casually.


</DL>



<H3><A NAME="SEC51">6.5.5 Numerical input and output</A></H3>

<P>
<A NAME="IDX365"></A>


<P>
<DL>
<DT><U>procedure:</U> <B>number-&#62;string</B> <I>number format</I>
<DD><A NAME="IDX366"></A>


<P>
The conventions used to produce the printed representation of a number can
be specified by a format, as described in section <A HREF="r3rs_8.html#SEC52">6.5.6 Formats</A>.
The procedure <CODE>number-&#62;string</CODE> takes a
<A NAME="IDX367"></A>
number and a format and returns as a string the printed representation of
the given number in the given format.  This procedure will mostly be
used by sophisticated users and in system programs.  In general, a naive
user will need to know nothing about the formats because the system
printer will have reasonable default formats for all types of
<I>number</I>s.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>string-&#62;number</B> <I>string exactness radix</I>
<DD><A NAME="IDX368"></A>


<P>
The system reader will construct reasonable default numerical types for
numbers expressed in each of the formats it recognizes.  A user who
needs control of the coercion from strings to numbers will use
<CODE>string-&#62;number</CODE>.
<A NAME="IDX369"></A>
<VAR>Exactness</VAR> must be a symbol, either <SAMP>`E'</SAMP> (for <I>exact</I>) or <SAMP>`I'</SAMP> (for <I>inexact</I>).  <VAR>Radix</VAR> must also be a symbol: <SAMP>`B'</SAMP> for
binary, <SAMP>`O'</SAMP> for octal, <SAMP>`D'</SAMP> for decimal, and <SAMP>`X'</SAMP> for
hexadecimal.  Returns a number of the maximally precise representation
expressed by the given <VAR>string</VAR>.  It is an error if <VAR>string</VAR> does
not express a number according to the grammar in section <A HREF="r3rs_9.html#SEC65">7.1.1 Lexical structure</A>.
 
</DL>


<P>
 


<H3><A NAME="SEC52">6.5.6 Formats</A></H3>

<P>
<A NAME="IDX370"></A>


<P>
A <EM>format</EM> is a list beginning with a <EM>format descriptor</EM>, which
is a symbol such as <SAMP>`sci'</SAMP>.  Following the descriptor are parameters
used by that descriptor, such as the number of significant digits to be
used.  Default values are supplied for any parameters that are omitted.
Modifiers may appear after the parameters, such as the <SAMP>`radix'</SAMP> and
<SAMP>`exactness'</SAMP> formats described below, which themselves take
parameters.


<P>
Details of particular formats such as <TT>sci</TT> and <TT>fix</TT> are given
in section <A HREF="r3rs_8.html#SEC53">6.5.7 Details of formats</A>.


<P>
For example, the format <SAMP>`(sci 5 2 (exactness s))'</SAMP> specifies that a
number is to be expressed in Fortran scientific format with 5
significant places and two places after the radix point, and that its
exactness prefix is to be suppressed.


<P>
In the following examples, the comment shows the format that was
used to produce the output shown:



<PRE>

123  +123  -123              ; (int)
123456789012345678901234567  ; (int)
355/113  +355/113  -355/113  ; (rat)
+123.45  -123.45             ; (fix 2)
3.14159265358979             ; (fix 14)
3.14159265358979             ; (flo 15)
123.450                      ; (flo 6)
-123.45e-1                   ; (sci 5 2)
123e3  123e-3  -123e-3       ; (sci 3 0)
-1+2i                        ; (rect (int) (int))
1.2@1.570796                 ; (polar (fix 1)
                             ;        (flo 7))

</PRE>

<P>
A format may specify that a number should be expressed in a particular
radix.  The radix prefix may also be suppressed.  For example, one may
express a complex number in polar form with the magnitude in octal and
the angle in decimal as follows:



<PRE>

#o1.2@#d1.570796327 ; (polar (flo 2 (radix o))
<A NAME="IDX371"></A>                    ;        (flo (radix d)))
#o1.2@1.570796327   ; (polar (flo 2 (radix o))
                    ;        (flo (radix d s)))

</PRE>

<P>
A format may specify that a number should be expressed with an explicit
exactness prefix (<TT>(exactness e)</TT>), or it may force the exactness to
be suppressed (<TT>(exactness s)</TT>).  For example, the following are
ways to express an inexact value for pi:



<PRE>

#i355/113           ; (rat (exactness e))
<A NAME="IDX372"></A>355/113             ; (rat (exactness s))
#i3.1416            ; (fix 4 (exactness e))

</PRE>

<P>
An attempt to produce more digits than are available in the internal
machine representation of a number will be marked with a "#"
filling the extra digits.  This is not a statement that the
implementation knows or keeps track of the significance of a number,
just that the machine will flag attempts to produce 20 digits of a
number that has only 15 digits of machine representation:



<PRE>

3.14158265358979#####   ; (flo 20 (exactness s))

</PRE>

<P>
 


<H3><A NAME="SEC53">6.5.7 Details of formats</A></H3>

<P>
<A NAME="IDX373"></A>


<P>
The format descriptors are:


<P>
<DL>
<DT><U>format:</U> <B>int</B>
<DD><A NAME="IDX374"></A>


<P>
Express as an integer.  The radix point is implicit.  If there are not
enough significant places then insignificant digits will be flagged.  For
example, an inexact integer 6.0238.10^23 (represented internally as a 7 digit
<I>flonum</I>) would be printed as



<PRE>
<TT>6023800#################
</TT>
</PRE>

</DL>

<P>
 
<DL>
<DT><U>format:</U> <B>rat</B> <I><VAR>n</VAR></I>
<DD><A NAME="IDX375"></A>


<P>
Express as a rational fraction.  <VAR>n</VAR> specifies the largest denominator
to be used in constructing a rational approximation to the number being
expressed.  If <VAR>n</VAR> is omitted it defaults to infinity.


</DL>

<P>
<DL>
<DT><U>format:</U> <B>fix</B> <I><VAR>n</VAR></I>
<DD><A NAME="IDX376"></A>


<P>
Express with a fixed radix point.  <VAR>n</VAR> specifies the number of places
to the right of the radix point.  <VAR>n</VAR> defaults to the size of a
single-precision <I>flonum</I>.  If there are not enough significant
places, then insignificant digits will be flagged.  For example,
an inexact 6.0238.10^23 (represented internally as a 7 digit <I>flonum</I>)
would be printed with a <TT>(fix 2)</TT> format as



<PRE>
<TT>6023800#################.##
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>format:</U> <B>flo</B> <I><VAR>n</VAR></I>
<DD><A NAME="IDX377"></A>


<P>
Express with a floating radix point.  <VAR>n</VAR> specifies the total number
of places to be displayed.  <VAR>n</VAR> defaults to the size of a
single-precision <I>flonum</I>.  If the number is out of range, it is
converted to <TT>(sci)</TT>.  <TT>(flo h)</TT> expresses <VAR>n</VAR> in floating
point format heuristically for human consumption. 
 
</DL>


<P>
<DL>
<DT><U>format:</U> <B>sci</B> <I><VAR>n</VAR> <VAR>m</VAR></I>
<DD><A NAME="IDX378"></A>


<P>
Express in exponential notation.  <VAR>n</VAR> specifies the total number of
places to be displayed.  <VAR>n</VAR> defaults to the size of a single-precision
<I>flonum</I>.  <VAR>m</VAR> specifies the number of places to the right of the
radix point.  <VAR>m</VAR> defaults to <VAR>n</VAR>-1.  <TT>(sci h)</TT> does heuristic
expression.
 
</DL>


<P>
<DL>
<DT><U>format:</U> <B>rect</B> <I><VAR>r</VAR> <VAR>i</VAR></I>
<DD><A NAME="IDX379"></A>


<P>
Express as a rectangular form complex number.  <VAR>r</VAR> and <VAR>i</VAR> are
formats for the real and imaginary parts respectively.  They default to
<TT>(heur)</TT>.
 
</DL>


<P>
<DL>
<DT><U>format:</U> <B>polar</B> <I><VAR>m</VAR> <VAR>a</VAR></I>
<DD><A NAME="IDX380"></A>


<P>
Express as a polar form complex number.  <VAR>m</VAR> and <VAR>a</VAR> are formats
for the magnitude and angle respectively.  <VAR>m</VAR> and <VAR>a</VAR> default to
<TT>(heur)</TT>.


</DL>

<P>
<DL>
<DT><U>format:</U> <B>heur</B>
<DD><A NAME="IDX381"></A>


<P>
Express heuristically using the minimum number of digits required to get an
expression that when coerced back to a number produces the original machine
representation.  <I>Exact</I> numbers are expressed as <TT>(int)</TT> or <TT>(rat)</TT>.  <I>Inexact</I> numbers are expressed as <TT>(flo h)</TT> or <TT>(sci
h)</TT> depending on their range.  Complex numbers are expressed in <TT>(rect)</TT>.  This is the normal default of the system printer.


</DL>

<P>
The following modifiers may be added to a numerical format specification:


<P>
<DL>
<DT><U>format:</U> <B>exactness</B> <I><VAR>s</VAR></I>
<DD><A NAME="IDX382"></A>


<P>
This controls the expression of the exactness prefix of a number.  <VAR>s</VAR>
must be a symbol, either <TT>E</TT> or <TT>S</TT>, indicating whether the
exactness is to be expressed or suppressed, respectively.  If no
exactness modifier is specified for a format then the exactness is by
default suppressed.  


</DL>

<P>
<DL>
<DT><U>format:</U> <B>radix</B> <I><VAR>r</VAR> <VAR>s</VAR></I>
<DD><A NAME="IDX383"></A>


<P>
This forces a number to be expressed in the radix <VAR>r</VAR>.  <VAR>r</VAR> may be
the symbol <TT>B</TT> (binary), <TT>O</TT> (octal), <TT>D</TT> (decimal), or <TT>X</TT>
(hex).
<VAR>s</VAR> must be a symbol, either <TT>E</TT> or <TT>S</TT>, indicating whether
the radix prefix is to be expressed or suppressed, respectively.
<VAR>s</VAR> defaults to <TT>E</TT> (expressed).  If no
radix modifier is specified then the default is decimal and the prefix is
suppressed.


</DL>



<H2><A NAME="SEC54">6.6 Characters</A></H2>

<P>
<A NAME="IDX384"></A>


<P>
Characters are objects that represent printed characters such as
letters and digits.  There is no requirement that the data type of
characters be disjoint from other data types; implementations are
encouraged to have a separate character data type, but may choose to
represent characters as integers, strings, or some other type.


<P>
Characters are written using the notation #\&#60;character&#62;
or #\&#60;character name&#62;.
For example:


<center>
<P>
 
</center>

<BLOCKQUOTE>
<DL COMPACT>

<DT><TT>#\a</TT>
<DD>
; lower case letter
<DT><TT>#\A</TT>
<DD>
; upper case letter
<DT><TT>#\(</TT>
<DD>
; left parenthesis
<DT><TT>#\ </TT>
<DD>
; the space character
<DT><TT>#\space</TT>
<DD>
; the preferred way to write a space
<DT><TT>#\newline</TT>
<DD>
; the newline character
<DT>
<DD>
</DL>
</BLOCKQUOTE>

<P>
Case is significant in #\&#60;character&#62;, but not in
#\&#60;character name&#62;.  If &#60;character&#62; in
#\&#60;character&#62; is alphabetic, then the character
following &#60;character&#62; must be a delimiter character such as a
space or parenthesis.  This rule resolves the ambiguous case where, for
example, the sequence of characters "<TT>#\ space</TT>"
could be taken to be either a representation of the space character or a
representation of the character "<TT>#\ s</TT>" followed
by a representation of the symbol "<TT>pace</TT>."


<P>
Characters written in the #\ notation are self-evaluating.
That is, they do not have to be quoted in programs.  The #\
notation is not an essential part of Scheme, however.  Even implementations
that support the #\ notation for input do not have to support
it for output.


<P>
Some of the procedures that operate on characters ignore the
difference between upper case and lower case.  The procedures that
ignore case have the suffix "<TT>-ci</TT>" (for "case
insensitive").  If the operation is a predicate, then the "<TT>-ci</TT>" suffix precedes the "<TT>?</TT>" at the end of the name.


<P>
<DL>
<DT><U>essential procedure:</U> <B>char?</B> <I>obj</I>
<DD><A NAME="IDX385"></A>


<P>
Returns <TT>#t</TT> if <VAR>obj</VAR> is a character, otherwise returns <TT>#f</TT>.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>char=?</B> <I>char1 char2</I>
<DD><A NAME="IDX386"></A>
<DT><U>essential procedure:</U> <B>char&#60;?</B> <I>char1 char2</I>
<DD><A NAME="IDX387"></A>
<DT><U>essential procedure:</U> <B>char&#62;?</B> <I>char1 char2</I>
<DD><A NAME="IDX388"></A>
<DT><U>essential procedure:</U> <B>char&#60;=?</B> <I>char1 char2</I>
<DD><A NAME="IDX389"></A>
<DT><U>essential procedure:</U> <B>char&#62;=?</B> <I>char1 char2</I>
<DD><A NAME="IDX390"></A>


<P>
These procedures impose a total ordering on the set of characters.  It
is guaranteed that under this ordering:



<UL>

<LI>

The upper case characters are in order.  For example, <SAMP>`(char&#60;? #\A #\B)'</SAMP> returns <TT>#t</TT>.
<LI>

The lower case characters are in order.  For example, <SAMP>`(char&#60;? #\a #\b)'</SAMP> returns <TT>#t</TT>.
<LI>

The digits are in order.  For example, <SAMP>`(char&#60;? #\0 #\9)'</SAMP> returns <TT>#t</TT>.
<LI>

Either all the digits precede all the upper case letters, or vice versa.
<LI>

Either all the digits precede all the lower case letters, or vice versa.

</UL>

<P>
Some implementations may generalize these procedures to take more than
two arguments, as with the corresponding numeric predicates.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>char-ci=?</B> <I>char1 char2</I>
<DD><A NAME="IDX391"></A>
<DT><U>procedure:</U> <B>char-ci&#60;?</B> <I>char1 char2</I>
<DD><A NAME="IDX392"></A>
<DT><U>procedure:</U> <B>char-ci&#62;?</B> <I>char1 char2</I>
<DD><A NAME="IDX393"></A>
<DT><U>procedure:</U> <B>char-ci&#60;=?</B> <I>char1 char2</I>
<DD><A NAME="IDX394"></A>
<DT><U>procedure:</U> <B>char-ci&#62;=?</B> <I>char1 char2</I>
<DD><A NAME="IDX395"></A>


<P>
These procedures are similar to <CODE>char=?</CODE> et cetera, but they treat
<A NAME="IDX396"></A>
upper case and lower case letters as the same.  For example, <SAMP>`(char-ci=? #\A #\a)'</SAMP> returns <TT>#t</TT>.  Some
implementations may generalize these procedures to take more than two
arguments, as with the corresponding numeric predicates.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>char-alphabetic?</B> <I>char</I>
<DD><A NAME="IDX397"></A>
<DT><U>procedure:</U> <B>char-numeric?</B> <I>char</I>
<DD><A NAME="IDX398"></A>
<DT><U>procedure:</U> <B>char-whitespace?</B> <I>char</I>
<DD><A NAME="IDX399"></A>


<P>
These procedures return <TT>#t</TT> if their arguments are alphabetic,
numeric, or whitespace characters, respectively, otherwise they return
<TT>#f</TT>.  The following remarks, which are specific to the ASCII
character set, are intended only as a guide:  The alphabetic characters
are the 52 upper and lower case letters.  The numeric characters are the
ten decimal digits.  The whitespace characters are space, tab, line
feed, form feed, and carriage return.
</DL>


<P>
<DL>
<DT><U>procedure:</U> <B>char-upper-case?</B> <I>letter</I>
<DD><A NAME="IDX400"></A>
<DT><U>procedure:</U> <B>char-lower-case?</B> <I>letter</I>
<DD><A NAME="IDX401"></A>


<P>
<VAR>Letter</VAR> must be an alphabetic character.
These procedures return <TT>#t</TT> if their arguments are upper case or
lower case characters, respectively, otherwise they return <TT>#f</TT>.
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>char-&#62;integer</B> <I>char</I>
<DD><A NAME="IDX402"></A>
<DT><U>essential procedure:</U> <B>integer-&#62;char</B> <I><VAR>n</VAR></I>
<DD><A NAME="IDX403"></A>


<P>
Given a character, <CODE>char-&#62;integer</CODE> returns an integer
<A NAME="IDX404"></A>
representation of the character.  Given an integer that is the image of
a character under <CODE>char-&#62;integer</CODE>, <CODE>integer-&#62;char</CODE>
<A NAME="IDX405"></A>
returns a character.  These procedures implement order isomorphisms
between the set of characters under the <CODE>char&#60;=?</CODE> ordering and some
<A NAME="IDX406"></A>
subset of the integers under the <CODE>&#60;=</CODE> ordering.  That is, if
<A NAME="IDX407"></A>



<PRE>
<TT>(char&#60;=? <VAR>a</VAR> <VAR>b</VAR>) => #t  </TT>and  (&#60;= <VAR>x</VAR> <VAR>y</VAR>) => #t

</PRE>

<P>
 and <VAR>x</VAR> and <VAR>y</VAR> are in the range of <CODE>char-&#62;integer</CODE>,
then



<PRE>
<TT>(&#60;= (char-&#62;integer <VAR>a</VAR>)
    (char-&#62;integer <VAR>b</VAR>))                 ==&#62;  #t

(char&#60;=? (integer-&#62;char <VAR>x</VAR>)
         (integer-&#62;char <VAR>y</VAR>))            ==&#62;  #t
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>char-upcase</B> <I>char</I>
<DD><A NAME="IDX408"></A>
<DT><U>procedure:</U> <B>char-downcase</B> <I>char</I>
<DD><A NAME="IDX409"></A>


<P>
These procedures return a character <VAR>char2</VAR> such that <SAMP>`(char-ci=? <VAR>char</VAR> <VAR>char2</VAR>)'</SAMP>.  In addition, if <VAR>char</VAR> is
alphabetic, then the result of <CODE>char-upcase</CODE> is upper case and the
<A NAME="IDX410"></A>
result of <CODE>char-downcase</CODE> is lower case.
<A NAME="IDX411"></A>


</DL>



<H2><A NAME="SEC55">6.7 Strings</A></H2>

<P>
<A NAME="IDX412"></A>


<P>
Strings are sequences of characters.  In some implementations of Scheme
they are immutable; other implementations provide destructive procedures
such as <CODE>string-set!</CODE> that alter string objects.
<A NAME="IDX413"></A>


<P>
Strings are written as sequences of characters enclosed within doublequotes
(<SAMP>`"'</SAMP>).  A doublequote can be written inside a string only by escaping
it with a backslash (\), as in



<PRE>

"The word \"recursion\" has many meanings."

</PRE>

<P>
A backslash can be written inside a string only by escaping it with another
backslash.  Scheme does not specify the effect of a backslash within a
string that is not followed by a doublequote or backslash.


<P>
A string may continue from one line to the next, but this is
usually a bad idea because the exact effect may vary from one computer
system to another.


<P>
The <EM>length</EM> of a string is the number of characters that it
contains.  This number is a non-negative integer that is fixed when the
string is created.  The <EM>valid indexes</EM> of a string are the
<A NAME="IDX414"></A>
exact non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.


<P>
In phrases such as "the characters of <VAR>string</VAR> beginning with
index <VAR>start</VAR> and ending with index <VAR>end</VAR>," it is understood
that the index <VAR>start</VAR> is inclusive and the index <VAR>end</VAR> is
exclusive.  Thus if <VAR>start</VAR> and <VAR>end</VAR> are the same index, a null
substring is referred to, and if <VAR>start</VAR> is zero and <VAR>end</VAR> is
the length of <VAR>string</VAR>, then the entire string is referred to.


<P>
Some of the procedures that operate on strings ignore the
difference between upper and lower case.  The versions that ignore case
have the suffix "<SAMP>`-ci'</SAMP>" (for "case insensitive").  If the
operation is a predicate, then the "<SAMP>`-ci'</SAMP>" suffix precedes the
"<SAMP>`?'</SAMP>" at the end of the name.


<P>
<DL>
<DT><U>essential procedure:</U> <B>string?</B> <I>obj</I>
<DD><A NAME="IDX415"></A>


<P>
Returns <TT>#t</TT> if <VAR>obj</VAR> is a string, otherwise returns <TT>#f</TT>.
</DL>


<P>
<DL>
<DT><U>procedure:</U> <B>make-string</B> <I><VAR>k</VAR></I>
<DD><A NAME="IDX416"></A>
<DT><U>procedure:</U> <B>make-string</B> <I><VAR>k</VAR> char</I>
<DD><A NAME="IDX417"></A>


<P>
<VAR>k</VAR> must be a non-negative integer, and <VAR>char</VAR> must be
a character.  <CODE>Make-string</CODE> returns a newly allocated string of
<A NAME="IDX418"></A>
length <VAR>k</VAR>.  If <VAR>char</VAR> is given, then all elements of the string
are initialized to <VAR>char</VAR>, otherwise the contents of the
<VAR>string</VAR> are unspecified.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>string-length</B> <I>string</I>
<DD><A NAME="IDX419"></A>


<P>
Returns the number of characters in the given <VAR>string</VAR>.
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>string-ref</B> <I>string <VAR>k</VAR></I>
<DD><A NAME="IDX420"></A>


<P>
<VAR>k</VAR> must be a valid index of <VAR>string</VAR>.
<CODE>String-ref</CODE> returns character <VAR>k</VAR> of <VAR>string</VAR> using zero-origin indexing.
<A NAME="IDX421"></A>
</DL>


<P>
<DL>
<DT><U>procedure:</U> <B>string-set!</B> <I>string k char</I>
<DD><A NAME="IDX422"></A>


<P>
<VAR>k</VAR> must be a valid index of <VAR>string</VAR>
.
<CODE>String-set!</CODE> stores <VAR>char</VAR> in element <VAR>k</VAR> of <VAR>string</VAR>
and returns an unspecified value.  


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>string=?</B> <I>string1 string2</I>
<DD><A NAME="IDX423"></A>
<DT><U>procedure:</U> <B>string-ci=?</B> <I>string1 string2</I>
<DD><A NAME="IDX424"></A>


<P>
Returns <TT>#t</TT> if the two strings are the same length and contain the same
characters in the same positions, otherwise returns <TT>#f</TT>.
<CODE>String-ci=?</CODE> treats
<A NAME="IDX425"></A>
upper and lower case letters as though they were the same character, but
<CODE>string=?</CODE> treats upper and lower case as distinct characters.
<A NAME="IDX426"></A>


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>string&#60;?</B> <I>string1 string2</I>
<DD><A NAME="IDX427"></A>
<DT><U>essential procedure:</U> <B>string&#62;?</B> <I>string1 string2</I>
<DD><A NAME="IDX428"></A>
<DT><U>essential procedure:</U> <B>string&#60;=?</B> <I>string1 string2</I>
<DD><A NAME="IDX429"></A>
<DT><U>essential procedure:</U> <B>string&#62;=?</B> <I>string1 string2</I>
<DD><A NAME="IDX430"></A>
<DT><U>procedure:</U> <B>string-ci&#60;?</B> <I>string1 string2</I>
<DD><A NAME="IDX431"></A>
<DT><U>procedure:</U> <B>string-ci&#62;?</B> <I>string1 string2</I>
<DD><A NAME="IDX432"></A>
<DT><U>procedure:</U> <B>string-ci&#60;=?</B> <I>string1 string2</I>
<DD><A NAME="IDX433"></A>
<DT><U>procedure:</U> <B>string-ci&#62;=?</B> <I>string1 string2</I>
<DD><A NAME="IDX434"></A>


<P>
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, <CODE>string&#60;?</CODE> is
<A NAME="IDX435"></A>
the lexicographic ordering on strings induced by the ordering
<CODE>char&#60;?</CODE> on characters.  If two strings differ in length but
<A NAME="IDX436"></A>
are the same up to the length of the shorter string, the shorter string
is considered to be lexicographically less than the longer string.


<P>
Implementations may generalize these and the <CODE>string=?</CODE> and
<CODE>string-ci=?</CODE> procedures to take more than two arguments, as with
the corresponding numeric predicates.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>substring</B> <I>string start end</I>
<DD><A NAME="IDX437"></A>


<P>
<VAR>String</VAR> must be a string, and <VAR>start</VAR> and <VAR>end</VAR>
must be exact integers satisfying


<center>
<P>
 0 &#60;= <VAR>start</VAR> &#60;= <VAR>end</VAR> &#60;= <TT>(string-length <VAR>string</VAR>).</TT>
</center>


<P>
<CODE>Substring</CODE> returns a newly allocated string formed from the characters of
<A NAME="IDX438"></A>
<VAR>string</VAR> beginning with index <VAR>start</VAR> (inclusive) and ending with index
<VAR>end</VAR> (exclusive).
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>string-append</B> <I>string1 string2</I>
<DD><A NAME="IDX439"></A>
<DT><U>procedure:</U> <B>string-append</B> <I><VAR>string</VAR> ...</I>
<DD><A NAME="IDX440"></A>


<P>
Returns a new string whose characters form the concatenation of the
given strings.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>string-&#62;list</B> <I>string</I>
<DD><A NAME="IDX441"></A>
<DT><U>essential procedure:</U> <B>list-&#62;string</B> <I>chars</I>
<DD><A NAME="IDX442"></A>


<P>
<CODE>String-&#62;list</CODE> returns a newly allocated list of the
<A NAME="IDX443"></A>
characters that make up the given string.  <CODE>List-&#62;string</CODE>
<A NAME="IDX444"></A>
returns a string formed from the characters in the list <VAR>chars</VAR>.
<CODE>String-&#62;list</CODE> and <CODE>list-&#62;string</CODE> are inverses so
far as <CODE>equal?</CODE> is concerned.  Implementations that provide
<A NAME="IDX445"></A>
destructive operations on strings should ensure that the result of
<CODE>list-&#62;string</CODE> is newly allocated.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>string-copy</B> <I>string</I>
<DD><A NAME="IDX446"></A>


<P>
Returns a newly allocated copy of the given <VAR>string</VAR>.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>string-fill!</B> <I>string char</I>
<DD><A NAME="IDX447"></A>


<P>
Stores <VAR>char</VAR> in every element of the given <VAR>string</VAR> and returns an
unspecified value.  


</DL>



<H2><A NAME="SEC56">6.8 Vectors</A></H2>

<P>
<A NAME="IDX448"></A>


<P>
Vectors are heterogenous mutable structures whose elements are indexed
by integers.


<P>
The <EM>length</EM> of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.  The <EM>valid indexes</EM> of a
<A NAME="IDX449"></A>
vector are the exact non-negative integers less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.


<P>
Vectors are written using the notation <TT>#(<VAR>obj</VAR> ...)</TT>.
For example, a vector of length 3 containing the number zero in element
0, the list <SAMP>`(2 2 2 2)'</SAMP> in element 1, and the string <SAMP>`"Anna"'</SAMP> in
element 2 can be written as following:



<PRE>

#(0 (2 2 2 2) "Anna")

</PRE>

<P>
Note that this is the external representation of a vector, not an
expression evaluating to a vector.  Like list constants, vector
constants must be quoted:



<PRE>

'#(0 (2 2 2 2) "Anna")  
          ==&#62;  #(0 (2 2 2 2) "Anna")

</PRE>

<P>
<DL>
<DT><U>essential procedure:</U> <B>vector?</B> <I>obj</I>
<DD><A NAME="IDX450"></A>
 
Returns <TT>#t</TT> if <VAR>obj</VAR> is a vector, otherwise returns <TT>#f</TT>.
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>make-vector</B> <I>k</I>
<DD><A NAME="IDX451"></A>
<DT><U>procedure:</U> <B>make-vector</B> <I>k fill</I>
<DD><A NAME="IDX452"></A>


<P>
Returns a newly allocated vector of <VAR>k</VAR> elements.  If a second
argument is given, then each element is initialized to <VAR>fill</VAR>.
Otherwise the initial contents of each element is unspecified.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>vector</B> <I>obj ...</I>
<DD><A NAME="IDX453"></A>


<P>
Returns a newly allocated vector whose elements contain the given
arguments.  Analogous to <CODE>list</CODE>.
<A NAME="IDX454"></A>



<PRE>
<TT>(vector 'a 'b 'c)                      ==&#62;  #(a b c)
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>vector-length</B> <I>vector</I>
<DD><A NAME="IDX455"></A>


<P>
Returns the number of elements in <VAR>vector</VAR>.
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>vector-ref</B> <I>vector k</I>
<DD><A NAME="IDX456"></A>


<P>
<VAR>k</VAR> must be a valid index of <VAR>vector</VAR>.
<CODE>Vector-ref</CODE> returns the contents of element <VAR>k</VAR> of
<A NAME="IDX457"></A>
<VAR>vector</VAR>.



<PRE>
<TT>(vector-ref '#(1 1 2 3 5 8 13 21) 5)  =>  8
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>vector-set!</B> <I>vector k obj</I>
<DD><A NAME="IDX458"></A>


<P>
<VAR>k</VAR> must be a valid index of <VAR>vector</VAR>.
<CODE>Vector-set!</CODE> stores <VAR>obj</VAR> in element <VAR>k</VAR> of <VAR>vector</VAR>.
<A NAME="IDX459"></A>
The value returned by <CODE>vector-set!</CODE> is unspecified.  



<PRE>
<TT>(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      
          ==&#62;  #(0 ("Sue" "Sue") "Anna")
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>vector-&#62;list</B> <I>vector</I>
<DD><A NAME="IDX460"></A>
<DT><U>essential procedure:</U> <B>list-&#62;vector</B> <I>list</I>
<DD><A NAME="IDX461"></A>


<P>
<CODE>Vector-&#62;list</CODE> returns a newly created list of the objects contained
<A NAME="IDX462"></A>
in the elements of <VAR>vector</VAR>.  <CODE>List-&#62;vector</CODE> returns a newly
<A NAME="IDX463"></A>
created vector initialized to the elements of the list <VAR>list</VAR>.



<PRE>
<TT>(vector-&#62;list '#(dah dah didah))  
          ==&#62;  (dah dah didah)
(list-&#62;vector '(dididit dah))   
          ==&#62;  #(dididit dah)
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>vector-fill!</B> <I>vector fill</I>
<DD><A NAME="IDX464"></A>


<P>
Stores <VAR>fill</VAR> in every element of <VAR>vector</VAR>.
The value returned by <CODE>vector-fill!</CODE> is unspecified.  


<P>
<A NAME="IDX465"></A>
</DL>




<H2><A NAME="SEC57">6.9 Control features</A></H2>

<P>
<A NAME="IDX466"></A>


<P>
 


<P>
This chapter describes various primitive procedures which control the
flow of program execution in special ways.
The <CODE>procedure?</CODE> predicate is also described here.
<A NAME="IDX467"></A>


<P>
<DL>
<DT><U>essential procedure:</U> <B>procedure?</B> <I>obj</I>
<DD><A NAME="IDX468"></A>


<P>
Returns <TT>#t</TT> if <VAR>obj</VAR> is a procedure, otherwise returns <TT>#f</TT>.



<PRE>
<TT>(procedure? car)                       ==&#62;  #t
(procedure? 'car)                      ==&#62;  #f
(procedure? (lambda (x) (* x x)))   
                                       ==&#62;  #t
(procedure? '(lambda (x) (* x x)))  
                                       ==&#62;  #f
(call-with-current-continuation procedure?)
                                       ==&#62;  #t
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>apply</B> <I>proc args</I>
<DD><A NAME="IDX469"></A>
<DT><U>procedure:</U> <B>apply</B> <I>proc arg1 ... args</I>
<DD><A NAME="IDX470"></A>


<P>
<VAR>Proc</VAR> must be a procedure and <VAR>args</VAR> must be a list.
The first (essential) form calls <VAR>proc</VAR> with the elements of
<VAR>args</VAR> as the actual arguments.  The second form is a generalization
of the first that calls <VAR>proc</VAR> with the elements of the list
<SAMP>`(append (list <VAR>arg1</VAR> ...) <VAR>args</VAR>)'</SAMP> as the actual
arguments.



<PRE>
<TT>(apply + (list 3 4))                   ==&#62;  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)               ==&#62;  30
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>map</B> <I>proc list</I>
<DD><A NAME="IDX471"></A>
<DT><U>procedure:</U> <B>map</B> <I>proc list1 list2 ...</I>
<DD><A NAME="IDX472"></A>


<P>
The <VAR>list</VAR>s must be lists, and <VAR>proc</VAR> must be a
procedure taking as many arguments as there are <I>list</I>s.  If more
than one <VAR>list</VAR> is given, then they must all be the same length.
<CODE>Map</CODE> applies <VAR>proc</VAR> element-wise to the elements of the
<A NAME="IDX473"></A>
<VAR>list</VAR>s and returns a list of the results.  The order in which
<VAR>proc</VAR> is applied to the elements of the <VAR>list</VAR>s is unspecified.



<PRE>
<TT>(map cadr '((a b) (d e) (g h)))   
          ==&#62;  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                
          ==&#62;  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))              ==&#62;  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b c)))                      ==&#62;  <EM>unspecified</EM>
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>for-each</B> <I>proc list</I>
<DD><A NAME="IDX474"></A>
<DT><U>procedure:</U> <B>for-each</B> <I>proc list1 list2 ...</I>
<DD><A NAME="IDX475"></A>


<P>
The arguments to <CODE>for-each</CODE> are like the arguments to <CODE>map</CODE>, but
<A NAME="IDX476"></A>
<CODE>for-each</CODE> calls <VAR>proc</VAR> for its side effects rather than for its
values.  Unlike <CODE>map</CODE>, <CODE>for-each</CODE> is guaranteed to call <VAR>proc</VAR> on
the elements of the <VAR>list</VAR>s in order from the first element to the
last, and the value returned by <CODE>for-each</CODE> is unspecified.



<PRE>
<TT>(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                   ==&#62;  #(0 1 4 9 16)
</TT>
</PRE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>force</B> <I>promise</I>
<DD><A NAME="IDX477"></A>


<P>
Forces the value of <VAR>promise</VAR> (see <CODE>delay</CODE>,
<A NAME="IDX478"></A>
section see section <A HREF="r3rs_6.html#SEC34">4.2.5 Delayed evaluation</A>).  If no value has been computed for
<A NAME="IDX479"></A>
the promise, then a value is computed and returned.  The value of the
promise is cached (or "memoized") so that if it is forced a second
time, the previously computed value is returned without any
recomputation.



<PRE>
<TT>(force (delay (+ 1 2)))                ==&#62;  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                                       ==&#62;  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))  
                                       ==&#62;  2
</TT>
</PRE>

<P>
<CODE>Force</CODE> and <CODE>delay</CODE> are mainly intended for programs written in
<A NAME="IDX480"></A>
functional style.  The following examples should not be considered to
illustrate good programming style, but they illustrate the property that
the value of a promise is computed at most once.



<PRE>
<TT>(define count 0)
(define p (delay (begin (set! count (+ count 1))
                        (* x 3))))
(define x 5)
count                                  ==&#62;  0
p                                      ==&#62;  <I></TT>a promise
(force p)                              ==&#62;  15
p                                      ==&#62;  <I></I>a promise, still
count                                  ==&#62;  1
(force p)                              ==&#62;  15
count                                  ==&#62;  1
</I>
</PRE>

<P>
Here is a possible implementation of <CODE>delay</CODE> and <CODE>force</CODE>.  We
define the expression



<PRE>
<TT>(delay &#60;expression&#62;)
</TT>
</PRE>

<P>
to have the same meaning as the procedure call



<PRE>
<TT>(make-promise (lambda () &#60;expression&#62;)),
</TT>
</PRE>

<P>
where <CODE>make-promise</CODE> is defined as follows:
<A NAME="IDX481"></A>



<PRE>
<TT>(define make-promise
  (lambda (proc)
    (let ((already-run? #f) (result #f))
      (lambda ()
        (cond ((not already-run?)
               (set! result (proc))
               (set! already-run? #t)))
        result))))
</TT>
</PRE>

<P>
Promises are implemented here as procedures of no arguments,
and <CODE>force</CODE> simply calls its argument.



<PRE>
<TT>(define force
  (lambda (object)
    (object)))
</TT>
</PRE>

<P>
Various extensions to this semantics of <CODE>delay</CODE> and <CODE>force</CODE>
are supported in some implementations:



<UL>

<LI>

Calling <CODE>force</CODE> on an object that is not a promise may simply
return the object.

<LI>

It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either <TT>#t</TT> or to <TT>#f</TT>,
depending on the implementation:


<PRE>
<TT>(eqv? (delay 1) 1)                ==&#62;  <EM>unspecified</EM>
(pair? (delay (cons 1 2)))        ==&#62;  <EM>unspecified</EM>
</TT>
</PRE>

<LI>

Some implementations will implement "implicit forcing," where
the value of a promise is forced by primitive procedures like <CODE>cdr</CODE>
and <CODE>+</CODE>:


<PRE>
<TT>(+ (delay (* 3 7)) 13)            ==&#62;  34
</TT>
</PRE>

</UL>

<P>
<A NAME="IDX482"></A>
<A NAME="IDX483"></A>
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>call-with-current-continuation</B> <I>proc</I>
<DD><A NAME="IDX484"></A>


<P>
 <VAR>Proc</VAR> must be a procedure of one
argument. The procedure <CODE>call-with-current-continuation</CODE> packages
<A NAME="IDX485"></A>
up the current continuation (see the rationale below) as an "escape
procedure" and passes it as an argument to
<A NAME="IDX486"></A>
<VAR>proc</VAR>.  The escape procedure is a Scheme procedure of one
argument that, if it is later passed a value, will ignore whatever
continuation is in effect at that later time and will give the value
instead to the continuation that was in effect when the escape procedure
was created.


<P>
The escape procedure created by <CODE>call-with-current-continuation</CODE> has
unlimited extent just like any other procedure in Scheme.  It may be stored
in variables or data structures and may be called as many times as desired.


<P>
The following examples show only the most common uses of
<CODE>call-with-current-continuation</CODE>.  If all real programs were as
simple as these examples, there would be no need for a procedure with
the power of <CODE>call-with-current-continuation</CODE>.



<PRE>
<TT>(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    #t))                               ==&#62;  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return #f))))))
          (r obj))))))

(list-length '(1 2 3 4))               ==&#62;  4

(list-length '(a b . c))               ==&#62;  #f
</TT>
</PRE>


<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
A common use of <CODE>call-with-current-continuation</CODE> is for
structured, non-local exits from loops or procedure bodies, but in fact
<CODE>call-with-current-continuation</CODE> is extremely useful for implementing a
wide variety of advanced control structures.


<P>
Whenever a Scheme expression is evaluated there is a <EM>continuation</EM>
wanting the result of the expression.  The continuation represents an
entire (default) future for the computation.  If the expression is
evaluated at top level, for example, then the continuation will take the
result, print it on the screen, prompt for the next input, evaluate it, and
so on forever.  Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the top level continuation to be printed.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers don't
think much about them.  On rare occasions, however, a programmer may
need to deal with continuations explicitly.
<CODE>Call-with-current-continuation</CODE> allows Scheme programmers to do
that by creating a procedure that acts just like the current
continuation.


<P>
Most programming languages incorporate one or more special-purpose
escape constructs with names like <TT>exit</TT>, <CODE>return</CODE>, or
<A NAME="IDX487"></A>
even <TT>goto</TT>.  In 1965, however, Peter Landin <A HREF="r3rs_12.html#BIB21">[Landin65]</A>
invented a general purpose escape operator called the J-operator.  John
Reynolds <A HREF="r3rs_12.html#BIB32">[Reynolds72]</A> described a simpler but equally powerful
construct in 1972.  The <CODE>catch</CODE> special form described by Sussman
<A NAME="IDX488"></A>
and Steele in the 1975 report on Scheme is exactly the same as
Reynolds's construct, though its name came from a less general construct
in MacLisp.  Several Scheme implementors noticed that the full power of the
<CODE>catch</CODE> construct could be provided by a procedure instead of by a
special syntactic construct, and the name
<CODE>call-with-current-continuation</CODE> was coined in 1982.  This name is
descriptive, but opinions differ on the merits of such a long name, and
some people use the name <CODE>call/cc</CODE> instead.
<A NAME="IDX489"></A>
</BLOCKQUOTE>

</DL>



<H2><A NAME="SEC58">6.10 Input and output</A></H2>

<P>
<A NAME="IDX490"></A>




<H3><A NAME="SEC59">6.10.1 Ports</A></H3>

<P>
<A NAME="IDX491"></A>


<P>
Ports represent input and output devices.  To Scheme, an input device is a
Scheme object that can deliver characters upon command, while an output device
is a Scheme object that can accept characters.


<P>
<DL>
<DT><U>essential procedure:</U> <B>call-with-input-file</B> <I>string proc</I>
<DD><A NAME="IDX492"></A>
<DT><U>essential procedure:</U> <B>call-with-output-file</B> <I>string proc</I>
<DD><A NAME="IDX493"></A>


<P>
<VAR>Proc</VAR> should be a procedure of one argument, and
<VAR>string</VAR> should be a string naming a file.  For
<CODE>call-with-input-file</CODE>, the file must already exist; for
<A NAME="IDX494"></A>
<CODE>call-with-output-file</CODE>, the effect is unspecified if the file
<A NAME="IDX495"></A>
already exists. These procedures call <VAR>proc</VAR> with one argument: the
port obtained by opening the named file for input or output.  If the
file cannot be opened, an error is signalled.  If the procedure returns,
then the port is closed automatically and the value yielded by the
procedure is returned.  If the procedure does not return, then Scheme
will not close the port unless it can prove that the port will never
again be used for a read or write operation.



<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
Because Scheme's escape procedures have unlimited extent, it  is
possible to escape from the current continuation but later to escape back in. 
If implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code using
both <CODE>call-with-current-continuation</CODE> and <CODE>call-with-input-file</CODE> or
<A NAME="IDX496"></A>
<CODE>call-with-output-file</CODE>.


</BLOCKQUOTE>

<P>
 
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>input-port?</B> <I>obj</I>
<DD><A NAME="IDX497"></A>
<DT><U>essential procedure:</U> <B>output-port?</B> <I>obj</I>
<DD><A NAME="IDX498"></A>


<P>
Returns <TT>#t</TT> if <VAR>obj</VAR> is an input port or output port
respectively, otherwise returns <TT>#f</TT>.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>current-input-port</B>
<DD><A NAME="IDX499"></A>
<DT><U>essential procedure:</U> <B>current-output-port</B>
<DD><A NAME="IDX500"></A>
 
Returns the current default input or output port.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>with-input-from-file</B> <I>string thunk</I>
<DD><A NAME="IDX501"></A>
<DT><U>procedure:</U> <B>with-output-to-file</B> <I>string thunk</I>
<DD><A NAME="IDX502"></A>


<P>
<VAR>Thunk</VAR> must be a procedure of no arguments, and
<VAR>string</VAR> must be a string naming a file.  For
<CODE>with-input-from-file</CODE>, the file must already exist; for
<A NAME="IDX503"></A>
<CODE>with-output-to-file</CODE>, the effect is unspecified if the file already
<A NAME="IDX504"></A>
exists. The file is opened for input or output, an input or output port
connected to it is made the default value returned by
<CODE>current-input-port</CODE> or <CODE>current-output-port</CODE>, and the
<A NAME="IDX505"></A>
<A NAME="IDX506"></A>
<VAR>thunk</VAR> is called with no arguments.  When the <VAR>thunk</VAR> returns,
the port is closed and the previous default is restored.
<CODE>With-input-from-file</CODE> and <CODE>with-output-to-file</CODE> return the
value yielded by <VAR>thunk</VAR>.
If an escape procedure
is used to escape from the continuation of these procedures, their
behavior is implementation dependent.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>open-input-file</B> <I>filename</I>
<DD><A NAME="IDX507"></A>
 
Takes a string naming an existing file and returns an input port capable of
delivering characters from the file.  If the file cannot be opened, an error is
signalled.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>open-output-file</B> <I>filename</I>
<DD><A NAME="IDX508"></A>


<P>
Takes a string naming an output file to be created and returns an output
port capable of writing characters to a new file by that name.  If the file
cannot be opened, an error is signalled.  If a file with the given name
already exists, the effect is unspecified.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>close-input-port</B> <I>port</I>
<DD><A NAME="IDX509"></A>
<DT><U>procedure:</U> <B>close-output-port</B> <I>port</I>
<DD><A NAME="IDX510"></A>


<P>
Closes the file associated with <VAR>port</VAR>, rendering the <VAR>port</VAR>
incapable of delivering or accepting characters.  


<P>
These routines have no effect if the file has already been closed.
The value returned is unspecified.


</DL>



<H3><A NAME="SEC60">6.10.2 Input</A></H3>

<P>
<A NAME="IDX511"></A>


<P>
    


<P>
<DL>
<DT><U>essential procedure:</U> <B>read</B>
<DD><A NAME="IDX512"></A>
<DT><U>essential procedure:</U> <B>read</B> <I>port</I>
<DD><A NAME="IDX513"></A>


<P>
<CODE>Read</CODE> converts written representations of Scheme objects into the
<A NAME="IDX514"></A>
objects themselves.  That is, it is a parser for the nonterminal
&#60;datum&#62; (see section see section <A HREF="r3rs_9.html#SEC66">7.1.2 External representations</A>).  <CODE>Read</CODE> returns the next
object parsable from the given input <VAR>port</VAR>, updating <VAR>port</VAR> to
point to the first character past the end of the written representation
of the object.


<P>
If an end of file is encountered in the input before any
characters are found that can begin an object, then an end of file
object is returned.  
 The port remains open, and further attempts
to read will also return an end of file object.  If an end of file is
encountered after the beginning of an object's written representation,
but the written representation is incomplete and therefore not parsable,
an error is signalled.


<P>
The <VAR>port</VAR> argument may be omitted, in which case it defaults to the
value returned by <CODE>current-input-port</CODE>.  It is an error to read from
<A NAME="IDX515"></A>
a closed port.
</DL>


<P>
<DL>
<DT><U>essential procedure:</U> <B>read-char</B>
<DD><A NAME="IDX516"></A>
<DT><U>essential procedure:</U> <B>read-char</B> <I>port</I>
<DD><A NAME="IDX517"></A>


<P>
Returns the next character available from the input <VAR>port</VAR>, updating
the <VAR>port</VAR> to point to the following character.  If no more characters
are available, an end of file object is returned.  <VAR>Port</VAR> may be
omitted, in which case it defaults to the value returned by <CODE>current-input-port</CODE>.


</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>char-ready?</B>
<DD><A NAME="IDX518"></A>
<DT><U>procedure:</U> <B>char-ready?</B> <I>port</I>
<DD><A NAME="IDX519"></A>


<P>
Returns <TT>#t</TT> if a character is ready on the input <VAR>port</VAR> and
returns <TT>#f</TT> otherwise.  If <CODE>char-ready</CODE> returns <TT>#t</TT> then
<A NAME="IDX520"></A>
the next <CODE>read-char</CODE> operation on the given <VAR>port</VAR> is guaranteed
<A NAME="IDX521"></A>
not to hang.  If the <VAR>port</VAR> is at end of file then <CODE>char-ready?</CODE>
returns <TT>#t</TT>.  <VAR>Port</VAR> may be omitted, in which case it defaults to
<A NAME="IDX522"></A>
the value returned by <CODE>current-input-port</CODE>.



<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Char-ready?</CODE> exists to make it possible for a program to
accept characters from interactive ports without getting stuck waiting for
input.  Any input editors associated with such ports must ensure that
characters whose existence has been asserted by <CODE>char-ready?</CODE> cannot
be rubbed out.  If <CODE>char-ready?</CODE> were to return <TT>#f</TT> at end of
file, a port at end of file would be indistinguishable from an interactive
port that has no ready characters.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>eof-object?</B> <I>obj</I>
<DD><A NAME="IDX523"></A>


<P>
Returns <TT>#t</TT> if <VAR>obj</VAR> is an end of file object, otherwise returns
<TT>#f</TT>.  The precise set of end of file objects will vary among
implementations, but in any case no end of file object will ever be a
character or an object that can be read in using <CODE>read</CODE>.


</DL>



<H3><A NAME="SEC61">6.10.3 Output</A></H3>

<P>
<A NAME="IDX524"></A>


<P>
 


<P>
<DL>
<DT><U>essential procedure:</U> <B>write</B> <I>obj</I>
<DD><A NAME="IDX525"></A>
<DT><U>essential procedure:</U> <B>write</B> <I>obj port</I>
<DD><A NAME="IDX526"></A>


<P>
Writes a representation of <VAR>obj</VAR> to the given <VAR>port</VAR>.  Strings that
appear in the written representation are enclosed in doublequotes, and
within those strings backslash and doublequote characters are
escaped by backslashes.  <CODE>Write</CODE> returns an unspecified value.  The
<A NAME="IDX527"></A>
<VAR>port</VAR> argument may be omitted, in which case it defaults to the value
returned by <CODE>current-output-port</CODE>.
<A NAME="IDX528"></A>


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>display</B> <I>obj</I>
<DD><A NAME="IDX529"></A>
<DT><U>essential procedure:</U> <B>display</B> <I>obj port</I>
<DD><A NAME="IDX530"></A>


<P>
Writes a representation of <VAR>obj</VAR> to the given <VAR>port</VAR>.  Strings
that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those strings.  In
those implementations that have a distinct character type, character
objects appear in the representation as if written by <CODE>write-char</CODE>
<A NAME="IDX531"></A>
instead of by <CODE>write</CODE>.  <CODE>Display</CODE> returns an unspecified value.
<A NAME="IDX532"></A>
The <VAR>port</VAR> argument may be omitted, in which case it defaults to the
value returned by <CODE>current-output-port</CODE>.



<BLOCKQUOTE>
<P>
<EM>Rationale:</EM>
<CODE>Write</CODE> is intended
for producing machine-readable output and <CODE>display</CODE> is for producing
human-readable output.  Implementations that allow "slashification"
within symbols will probably want <CODE>write</CODE> but not <CODE>display</CODE> to
slashify funny characters in symbols.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>newline</B>
<DD><A NAME="IDX533"></A>
<DT><U>essential procedure:</U> <B>newline</B> <I>port</I>
<DD><A NAME="IDX534"></A>


<P>
Writes an end of line to <VAR>port</VAR>.  Exactly how this is done differs
from one operating system to another.  Returns an unspecified value.
The <VAR>port</VAR> argument may be omitted, in which case it defaults to the
value returned by <CODE>current-output-port</CODE>.


</DL>

<P>
<DL>
<DT><U>essential procedure:</U> <B>write-char</B> <I>char</I>
<DD><A NAME="IDX535"></A>
<DT><U>essential procedure:</U> <B>write-char</B> <I>char port</I>
<DD><A NAME="IDX536"></A>


<P>
Writes the character <VAR>char</VAR> (not a written representation of the
character) to the given <VAR>port</VAR> and returns an unspecified value.  The
<VAR>port</VAR> argument may be omitted, in which case it defaults to the value
returned by <CODE>current-output-port</CODE>.


</DL>



<H3><A NAME="SEC62">6.10.4 User interface</A></H3>

<P>
<A NAME="IDX537"></A>


<P>
Questions of user interface generally fall outside of the domain of this
report.  However, the following operations are important enough to
deserve description here.


<P>
<DL>
<DT><U>essential procedure:</U> <B>load</B> <I>filename</I>
<DD><A NAME="IDX538"></A>


<P>
<VAR>Filename</VAR> should be a string naming an existing file
containing Scheme source code. The <CODE>load</CODE> procedure reads
<A NAME="IDX539"></A>
expressions and definitions from the file and evaluates them
sequentially.  It is unspecified whether the results of the expressions
are printed.  The <CODE>load</CODE> procedure does not affect the values
returned by <CODE>current-input-port</CODE> and <CODE>current-output-port</CODE>.
<A NAME="IDX540"></A>
<A NAME="IDX541"></A>
<CODE>Load</CODE> returns an unspecified value.



<BLOCKQUOTE>
<P>
<EM>Note:</EM>
For portability, <CODE>load</CODE> must operate on source files.
Its operation on other kinds of files necessarily varies among
implementations.
</BLOCKQUOTE>

</DL>

<P>
<DL>
<DT><U>procedure:</U> <B>transcript-on</B> <I>filename</I>
<DD><A NAME="IDX542"></A>
<DT><U>procedure:</U> <B>transcript-off</B>
<DD><A NAME="IDX543"></A>


<P>
<VAR>Filename</VAR> must be a string naming an output file to be
created. The effect of <CODE>transcript-on</CODE> is to open the named file
<A NAME="IDX544"></A>
for output, and to cause a transcript of subsequent interaction between
the user and the Scheme system to be written to the file.  The
transcript is ended by a call to <CODE>transcript-off</CODE>, which closes the
<A NAME="IDX545"></A>
transcript file.  Only one transcript may be in progress at any time,
though some implementations may relax this restriction.  The values
returned by these procedures are unspecified.


</DL>
<P>
         


<P></P><HR>
 [<A HREF="r3rs_toc.html">Contents</A>] &#160; [<A HREF="r3rs_7.html">Back</A>] &#160; [<A>Prev</A>] &#160; [<A>Up</A>] &#160; [<A>Next</A>] &#160; [<A HREF="r3rs_9.html">Forward</A>] &#160;

</BODY>
</HTML>
